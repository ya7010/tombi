FAIL valid/inline-table/array-values
     inline table must be single line
     inline table must be single line
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       # "No newlines are allowed between the curly braces unless they are valid within
       # a value"

       a = { a = [
       ]}

       b = { a = [
       		1,
       		2,
       	], b = [
       		3,
       		4,
       	]}

     output from parser-cmd (stderr):
       inline table must be single line
       inline table must be single line
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/inline-table/multiline
     inline table must be single line
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       tbl_multiline = { a = 1, b = """
       multiline
       """, c = """and yet
       another line""", d = 4 }

     output from parser-cmd (stderr):
       inline table must be single line
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/key/dotted-1
     Could not find key "name.first" in parser output.

     input sent to parser-cmd:
       name.first = "Arthur"
       "name".'last' = "Dent"

       many.dots.dot.dot.dot = 42

     output from parser-cmd (stdout):
       {
         "many": {
           "dots": {
             "dot": {
               "dot": {
                 "dot": {"type": "integer", "value": "42"}
               }
             }
           }
         },
         "name": {
           "last": {"type": "string", "value": "Dent"}
         }
       }

     want:
       {
           "many": {
               "dots": {
                   "dot": {
                       "dot": {
                           "dot": {"type": "integer", "value": "42"}
                       }
                   }
               }
           },
           "name": {
               "first": {"type": "string", "value": "Arthur"},
               "last":  {"type": "string", "value": "Dent"}
           }
       }

FAIL valid/key/dotted-2
     Could not find key "count.a" in parser output.

     input sent to parser-cmd:
       # Note: this file contains literal tab characters.

       # Space are ignored, and key parts can be quoted.
       count.a       = 1
       count . b     = 2
       "count"."c"   = 3
       "count" . "d" = 4
       'count'.'e'   = 5
       'count' . 'f' = 6
       "count".'g'   = 7
       "count" . 'h' = 8
       count.'i'     = 9
       count 	.	 'j'	   = 10
       "count".k     = 11
       "count" . l   = 12

     output from parser-cmd (stdout):
       {
         "count": {
           "e": {"type": "integer", "value": "5"},
           "f": {"type": "integer", "value": "6"}
         }
       }

     want:
       {
           "count": {
               "a": {"type": "integer", "value": "1"},
               "b": {"type": "integer", "value": "2"},
               "c": {"type": "integer", "value": "3"},
               "d": {"type": "integer", "value": "4"},
               "e": {"type": "integer", "value": "5"},
               "f": {"type": "integer", "value": "6"},
               "g": {"type": "integer", "value": "7"},
               "h": {"type": "integer", "value": "8"},
               "i": {"type": "integer", "value": "9"},
               "j": {"type": "integer", "value": "10"},
               "k": {"type": "integer", "value": "11"},
               "l": {"type": "integer", "value": "12"}
           }
       }

FAIL valid/key/escapes
     Could not find key "\b" in parser output.

     input sent to parser-cmd:
       "\n" = "newline"
       "\b" = "bell"
       "\u00c0" = "latin capital letter A with grave"
       "\"" = "just a quote"

       ["backsp\b\b"]

       ["\"quoted\""]
       quote = true

       ["a.b"."\u00c0"]

     output from parser-cmd (stdout):
       {
         "\"":         {"type": "string", "value": "just a quote"},
         "\\b":        {"type": "string", "value": "bell"},
         "\\n":        {"type": "string", "value": "newline"},
         "\\u00c0":    {"type": "string", "value": "latin capital letter A with grave"},
         "backsp\\b\\b": {},
         "\"quoted\"": {
           "quote": {"type": "bool", "value": "true"}
         },
         "a.b": {
           "\\u00c0": {}
         }
       }

     want:
       {
           "\b":         {"type": "string", "value": "bell"},
           "\n":         {"type": "string", "value": "newline"},
           "\"":         {"type": "string", "value": "just a quote"},
           "backsp\b\b": {},
           "√Ä":          {"type": "string", "value": "latin capital letter A with grave"},
           "\"quoted\"": {
               "quote": {"type": "bool", "value": "true"}
           },
           "a.b": {
               "√Ä": {}
           }
       }

FAIL valid/key/numeric-dotted
     Could not find key "1" in parser output.

     input sent to parser-cmd:
       1.2 = 3

     output from parser-cmd (stdout):
       {
         "1.2": {"type": "integer", "value": "3"}
       }

     want:
       {
           "1": {
               "2": {"type": "integer", "value": "3"}
           }
       }

FAIL valid/key/quoted-unicode
     Could not find key "\x00" in parser output.

     input sent to parser-cmd:

       "\u0000" = "null"
       '\u0000' = "different key"
       "\u0008 \u000c \U00000041 \u007f \u0080 \u00ff \ud7ff \ue000 \uffff \U00010000 \U0010ffff" = "escaped key"

       "~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø" = "basic key"
       'l ~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø' = "literal key"

     output from parser-cmd (stdout):
       {
         "\\u0000":                                                                                  {"type": "string", "value": "different key"},
         "\\u0008 \\u000c \\U00000041 \\u007f \\u0080 \\u00ff \\ud7ff \\ue000 \\uffff \\U00010000 \\U0010ffff": {"type": "string", "value": "escaped key"},
         "l ~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø":                                                                          {"type": "string", "value": "literal key"},
         "~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø":                                                                            {"type": "string", "value": "basic key"}
       }

     want:
       {
           "\u0000":               {"type": "string", "value": "null"},
           "\b \f A  ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø": {"type": "string", "value": "escaped key"},
           "\\u0000":              {"type": "string", "value": "different key"},
           "l ~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø":      {"type": "string", "value": "literal key"},
           "~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø":        {"type": "string", "value": "basic key"}
       }

FAIL valid/key/space
     Could not find key " tbl .\ttab\ttab\t" in parser output.

     input sent to parser-cmd:
       # Keep whitespace inside quotes keys at all positions.
       "a b"   = 1
       " c d " = 2

       [ " tbl " ]
       "\ttab\ttab\t" = "tab"

     output from parser-cmd (stdout):
       {
         " c d ": {"type": "integer", "value": "2"},
         "a b":   {"type": "integer", "value": "1"},
         " tbl ": {
           "\\ttab\\ttab\\t": {"type": "string", "value": "tab"}
         }
       }

     want:
       {
           " c d ": {"type": "integer", "value": "2"},
           "a b":   {"type": "integer", "value": "1"},
           " tbl ": {
               "\ttab\ttab\t": {"type": "string", "value": "tab"}
           }
       }

FAIL valid/key/start
     invalid token
     invalid token
     invalid token
     invalid token
     invalid token
     invalid token
     invalid token
     invalid token
     expected key
     expected ']'
     expected key
     expected '='
     expected value
     expected key
     expected ']'
     expected key
     expected '='
     expected value
     expected key
     expected ']'
     expected key
     expected '='
     expected value
     expected key
     expected '='
     expected value
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       # Table and keys can start with any character; there is no requirement for it to
       # start with a letter.

       [-key]
       -key = 1

       [_key]
       _key = 2

       [1key]
       1key = 3

       [-]
       - = 4

       [_]
       _ = 5

       [1]
       1 = 6

       [---]
       --- = 7

       [___]
       ___ = 8

       [111]
       111 = 9

       [inline]
       --- = {--- = 10, ___ = 11, 111 = 12}

     output from parser-cmd (stderr):
       invalid token
       invalid token
       invalid token
       invalid token
       invalid token
       invalid token
       invalid token
       invalid token
       expected key
       expected ']'
       expected key
       expected '='
       expected value
       expected key
       expected ']'
       expected key
       expected '='
       expected value
       expected key
       expected ']'
       expected key
       expected '='
       expected value
       expected key
       expected '='
       expected value
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/spec/keys-7
     Could not find key "3" in parser output.

     input sent to parser-cmd:
       3.14159 = "pi"

     output from parser-cmd (stdout):
       {
         "3.14159": {"type": "string", "value": "pi"}
       }

     want:
       {
           "3": {
               "14159": {"type": "string", "value": "pi"}
           }
       }

FAIL valid/spec/string-0
     Values for key "str" don't match:
       Expected:     I'm a string. "You can quote me". Name	Jos√©
     Location	SF.
       Your encoder: I'm a string. "You can quote me". Name\tJos\u00E9\nLocation\tSF.

     input sent to parser-cmd:
       str = "I'm a string. \"You can quote me\". Name\tJos\u00E9\nLocation\tSF."

     output from parser-cmd (stdout):
       {
         "str": {
           "type":  "string",
           "value": "I'm a string. \"You can quote me\". Name\\tJos\\u00E9\\nLocation\\tSF."
         }
       }

     want:
       {
           "str": {"type": "string", "value": "I'm a string. \"You can quote me\". Name\tJos√©\nLocation\tSF."}
       }

FAIL valid/spec/string-1
     Values for key "str1" don't match:
       Expected:     Roses are red
     Violets are blue
       Your encoder:
     Roses are red
     Violets are blue

     input sent to parser-cmd:
       str1 = """
       Roses are red
       Violets are blue"""

     output from parser-cmd (stdout):
       {
         "str1": {"type": "string", "value": "\nRoses are red\nViolets are blue"}
       }

     want:
       {
           "str1": {"type": "string", "value": "Roses are red\nViolets are blue"}
       }

FAIL valid/spec/string-2
     Values for key "str2" don't match:
       Expected:     Roses are red
     Violets are blue
       Your encoder: Roses are red\nViolets are blue

     input sent to parser-cmd:
       # On a Unix system, the above multi-line string will most likely be the same as:
       str2 = "Roses are red\nViolets are blue"

       # On a Windows system, it will most likely be equivalent to:
       str3 = "Roses are red\r\nViolets are blue"

     output from parser-cmd (stdout):
       {
         "str2": {"type": "string", "value": "Roses are red\\nViolets are blue"},
         "str3": {"type": "string", "value": "Roses are red\\r\\nViolets are blue"}
       }

     want:
       {
           "str2": {"type": "string", "value": "Roses are red\nViolets are blue"},
           "str3": {"type": "string", "value": "Roses are red\r\nViolets are blue"}
       }

FAIL valid/spec/string-3
     Values for key "str2" don't match:
       Expected:     The quick brown fox jumps over the lazy dog.
       Your encoder:
     The quick brown \
 
 
       fox jumps over \
         the lazy dog.

     input sent to parser-cmd:
       # The following strings are byte-for-byte equivalent:
       str1 = "The quick brown fox jumps over the lazy dog."

       str2 = """
       The quick brown \


         fox jumps over \
           the lazy dog."""

       str3 = """\
              The quick brown \
              fox jumps over \
              the lazy dog.\
              """

     output from parser-cmd (stdout):
       {
         "str1": {"type": "string", "value": "The quick brown fox jumps over the lazy dog."},
         "str2": {"type": "string", "value": "\nThe quick brown \\\n\n\n  fox jumps over \\\n    the lazy dog."},
         "str3": {
           "type":  "string",
           "value": "\\\n       The quick brown \\\n       fox jumps over \\\n       the lazy dog.\\\n       "
         }
       }

     want:
       {
           "str1": {"type": "string", "value": "The quick brown fox jumps over the lazy dog."},
           "str2": {"type": "string", "value": "The quick brown fox jumps over the lazy dog."},
           "str3": {"type": "string", "value": "The quick brown fox jumps over the lazy dog."}
       }

FAIL valid/spec/string-4
     invalid token
     invalid multi-line basic strings
     unknown line
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       str4 = """Here are two quotation marks: "". Simple enough."""
       # str5 = """Here are three quotation marks: """."""  # INVALID
       str5 = """Here are three quotation marks: ""\"."""
       str6 = """Here are fifteen quotation marks: ""\"""\"""\"""\"""\"."""

       # "This," she said, "is just a pointless statement."
       str7 = """"This," she said, "is just a pointless statement.""""

     output from parser-cmd (stderr):
       invalid token
       invalid multi-line basic strings
       unknown line
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/spec/string-5
     invalid key
     expected '='
     unknown line
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       # What you see is what you get.
       winpath  = 'C:\Users\nodejs\templates'
       winpath2 = '\\ServerX\admin$\system32\'
       quoted   = 'Tom "Dubs" Preston-Werner'
       regex    = '<\i\c*\s*>'

     output from parser-cmd (stderr):
       invalid key
       expected '='
       unknown line
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/spec/string-6
     Values for key "lines" don't match:
       Expected:     The first newline is
     trimmed in raw strings.
        All other whitespace
        is preserved.
 
       Your encoder:
     The first newline is
     trimmed in raw strings.
        All other whitespace
        is preserved.

     input sent to parser-cmd:
       regex2 = '''I [dw]on't need \d{2} apples'''
       lines  = '''
       The first newline is
       trimmed in raw strings.
          All other whitespace
          is preserved.
       '''

     output from parser-cmd (stdout):
       {
         "regex2": {"type": "string", "value": "I [dw]on't need \\d{2} apples"},
         "lines": {
           "type":  "string",
           "value": "\nThe first newline is\ntrimmed in raw strings.\n   All other whitespace\n   is preserved.\n"
         }
       }

     want:
       {
           "lines":  {"type": "string", "value": "The first newline is\ntrimmed in raw strings.\n   All other whitespace\n   is preserved.\n"},
           "regex2": {"type": "string", "value": "I [dw]on't need \\d{2} apples"}
       }

FAIL valid/spec/string-7
     expected '='
     expected value
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       quot15 = '''Here are fifteen quotation marks: """""""""""""""'''

       # apos15 = '''Here are fifteen apostrophes: ''''''''''''''''''  # INVALID
       apos15 = "Here are fifteen apostrophes: '''''''''''''''"

       # 'That,' she said, 'is still pointless.'
       str = ''''That,' she said, 'is still pointless.''''

     output from parser-cmd (stderr):
       expected '='
       expected value
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/string/ends-in-whitespace-escape
     Values for key "beee" don't match:
       Expected:     heeee
     geeee
       Your encoder:
     heeee
     geeee\

     input sent to parser-cmd:
       beee = """
       heeee
       geeee\


             """

     output from parser-cmd (stdout):
       {
         "beee": {"type": "string", "value": "\nheeee\ngeeee\\  \n\n\n      "}
       }

     want:
       {
           "beee": {"type": "string", "value": "heeee\ngeeee"}
       }

FAIL valid/string/escape-tricky
     invalid basic string
     invalid token
     invalid key
     expected value
     unknown line
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       end_esc = "String does not end here\" but ends here\\"
       lit_end_esc = 'String ends here\'

       multiline_unicode = """
       \u00a0"""

       multiline_not_unicode = """
       \\u0041"""

       multiline_end_esc = """When will it end? \"""...""\" should be here\""""

       lit_multiline_not_unicode = '''
       \u007f'''

       lit_multiline_end = '''There is no escape\'''

     output from parser-cmd (stderr):
       invalid basic string
       invalid token
       invalid key
       expected value
       unknown line
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/string/escaped-escape
     Values for key "answer" don't match:
       Expected:     \x64
       Your encoder: \\x64

     input sent to parser-cmd:
       answer = "\\x64"

     output from parser-cmd (stdout):
       {
         "answer": {"type": "string", "value": "\\\\x64"}
       }

     want:
       {
           "answer": {"type": "string", "value": "\\x64"}
       }

FAIL valid/string/escapes
     Values for key "backslash" don't match:
       Expected:     |\.
       Your encoder: |\\.

     input sent to parser-cmd:
       backspace     = "|\b."
       tab           = "|\t."
       newline       = "|\n."
       formfeed      = "|\f."
       carriage      = "|\r."
       quote         = "|\"."
       backslash     = "|\\."
       delete        = "|\u007F."
       unitseparator = "|\u001F."

       # \u is escaped, so should NOT be interperted as a \u escape.
       notunicode1   = "|\\u."
       notunicode2   = "|\u005Cu."
       notunicode3   = "|\\u0075."
       notunicode4   = "|\\\u0075."

     output from parser-cmd (stdout):
       {
         "backslash":     {"type": "string", "value": "|\\\\."},
         "backspace":     {"type": "string", "value": "|\\b."},
         "carriage":      {"type": "string", "value": "|\\r."},
         "delete":        {"type": "string", "value": "|\\u007F."},
         "formfeed":      {"type": "string", "value": "|\\f."},
         "newline":       {"type": "string", "value": "|\\n."},
         "notunicode1":   {"type": "string", "value": "|\\\\u."},
         "notunicode2":   {"type": "string", "value": "|\\u005Cu."},
         "notunicode3":   {"type": "string", "value": "|\\\\u0075."},
         "notunicode4":   {"type": "string", "value": "|\\\\\\u0075."},
         "quote":         {"type": "string", "value": "|\"."},
         "tab":           {"type": "string", "value": "|\\t."},
         "unitseparator": {"type": "string", "value": "|\\u001F."}
       }

     want:
       {
           "backslash":     {"type": "string", "value": "|\\."},
           "backspace":     {"type": "string", "value": "|\b."},
           "carriage":      {"type": "string", "value": "|\r."},
           "delete":        {"type": "string", "value": "|."},
           "formfeed":      {"type": "string", "value": "|\f."},
           "newline":       {"type": "string", "value": "|\n."},
           "notunicode1":   {"type": "string", "value": "|\\u."},
           "notunicode2":   {"type": "string", "value": "|\\u."},
           "notunicode3":   {"type": "string", "value": "|\\u0075."},
           "notunicode4":   {"type": "string", "value": "|\\u."},
           "quote":         {"type": "string", "value": "|\"."},
           "tab":           {"type": "string", "value": "|\t."},
           "unitseparator": {"type": "string", "value": "|\u001f."}
       }

FAIL valid/string/multiline
     Values for key "equivalent_three" don't match:
       Expected:     The quick brown fox jumps over the lazy dog.
       Your encoder: \
            The quick brown \
            fox jumps over \
            the lazy dog.\

     input sent to parser-cmd:
       # NOTE: this file includes some literal tab characters.

       equivalent_one = "The quick brown fox jumps over the lazy dog."
       equivalent_two = """
       The quick brown \


         fox jumps over \
           the lazy dog."""

       equivalent_three = """\
              The quick brown \
              fox jumps over \
              the lazy dog.\
              """

       whitespace-after-bs = """\
              The quick brown \
              fox jumps over \
              the lazy dog.\
              """

       no-space = """a\
           b"""

       # Has tab character.
       keep-ws-before = """a   	\
          b"""

       escape-bs-1 = """a \\
       b"""

       escape-bs-2 = """a \\\
       b"""

       escape-bs-3 = """a \\\\
         b"""

     output from parser-cmd (stdout):
       {
         "equivalent_one": {"type": "string", "value": "The quick brown fox jumps over the lazy dog."},
         "equivalent_two": {"type": "string", "value": "\nThe quick brown \\\n\n\n  fox jumps over \\\n    the lazy dog."},
         "escape-bs-1":    {"type": "string", "value": "a \\\\\nb"},
         "escape-bs-2":    {"type": "string", "value": "a \\\\\\\nb"},
         "escape-bs-3":    {"type": "string", "value": "a \\\\\\\\\n  b"},
         "keep-ws-before": {"type": "string", "value": "a   \t\\\n   b"},
         "no-space":       {"type": "string", "value": "a\\\n    b"},
         "equivalent_three": {
           "type":  "string",
           "value": "\\\n       The quick brown \\\n       fox jumps over \\\n       the lazy dog.\\\n       "
         },
         "whitespace-after-bs": {
           "type":  "string",
           "value": "\\\n       The quick brown \\\n       fox jumps over \\   \n       the lazy dog.\\\t\n       "
         }
       }

     want:
       {
           "equivalent_one":      {"type": "string", "value": "The quick brown fox jumps over the lazy dog."},
           "equivalent_three":    {"type": "string", "value": "The quick brown fox jumps over the lazy dog."},
           "equivalent_two":      {"type": "string", "value": "The quick brown fox jumps over the lazy dog."},
           "escape-bs-1":         {"type": "string", "value": "a \\\nb"},
           "escape-bs-2":         {"type": "string", "value": "a \\b"},
           "escape-bs-3":         {"type": "string", "value": "a \\\\\n  b"},
           "keep-ws-before":      {"type": "string", "value": "a   \tb"},
           "no-space":            {"type": "string", "value": "ab"},
           "whitespace-after-bs": {"type": "string", "value": "The quick brown fox jumps over the lazy dog."}
       }

FAIL valid/string/multiline-empty
     expected '='
     expected value
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       empty-1 = """"""

       # A newline immediately following the opening delimiter will be trimmed.
       empty-2 = """
       """

       # \ at the end of line trims newlines as well; note that last \ is followed by
       # two spaces, which are ignored.
       empty-3 = """\
           """
       empty-4 = """\
          \
          \
          """

     output from parser-cmd (stderr):
       expected '='
       expected value
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/string/multiline-escaped-crlf
     Values for key "0" don't match:
       Expected:
       Your encoder: \

     input sent to parser-cmd:
       # The following line should be an unescaped backslash followed by a Windows
       # newline sequence ("\r\n")
       0="""\
       """

     output from parser-cmd (stdout):
       {
         "0": {"type": "string", "value": "\\\r\n"}
       }

     want:
       {
           "0": {"type": "string", "value": ""}
       }

FAIL valid/string/multiline-quotes
     invalid key
     invalid key
     expected '='
     expected value
     expected '='
     expected '='
     expected value
     expected '='
     unknown line
     expected '='
     expected value
     unknown line
     expected '='
     expected value
     unknown line
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       # Make sure that quotes inside multiline strings are allowed, including right
       # after the opening '''/""" and before the closing '''/"""

       lit_one = ''''one quote''''
       lit_two = '''''two quotes'''''
       lit_one_space = ''' 'one quote' '''
       lit_two_space = ''' ''two quotes'' '''

       one = """"one quote""""
       two = """""two quotes"""""
       one_space = """ "one quote" """
       two_space = """ ""two quotes"" """

       mismatch1 = """aaa'''bbb"""
       mismatch2 = '''aaa"""bbb'''

       # Three opening """, then one escaped ", then two "" (allowed), and then three
       # closing """
       escaped = """lol\""""""

       five-quotes = """
       Closing with five quotes
       """""
       four-quotes = """
       Closing with four quotes
       """"

     output from parser-cmd (stderr):
       invalid key
       invalid key
       expected '='
       expected value
       expected '='
       expected '='
       expected value
       expected '='
       unknown line
       expected '='
       expected value
       unknown line
       expected '='
       expected value
       unknown line
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/string/nl
     Values for key "nl_end" don't match:
       Expected:     value
 
       Your encoder: value\n

     input sent to parser-cmd:
       nl_mid = "val\nue"
       nl_end = """value\n"""

       lit_nl_end = '''value\n'''
       lit_nl_mid = 'val\nue'
       lit_nl_uni = 'val\ue'

     output from parser-cmd (stdout):
       {
         "lit_nl_end": {"type": "string", "value": "value\\n"},
         "lit_nl_mid": {"type": "string", "value": "val\\nue"},
         "lit_nl_uni": {"type": "string", "value": "val\\ue"},
         "nl_end":     {"type": "string", "value": "value\\n"},
         "nl_mid":     {"type": "string", "value": "val\\nue"}
       }

     want:
       {
           "lit_nl_end": {"type": "string", "value": "value\\n"},
           "lit_nl_mid": {"type": "string", "value": "val\\nue"},
           "lit_nl_uni": {"type": "string", "value": "val\\ue"},
           "nl_end":     {"type": "string", "value": "value\n"},
           "nl_mid":     {"type": "string", "value": "val\nue"}
       }

FAIL valid/string/quoted-unicode
     Values for key "escaped_string" don't match:
       Expected:         A  ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø
       Your encoder: \u0000 \u0008 \u000c \U00000041 \u007f \u0080 \u00ff \ud7ff \ue000 \uffff \U00010000 \U0010ffff

     input sent to parser-cmd:

       escaped_string = "\u0000 \u0008 \u000c \U00000041 \u007f \u0080 \u00ff \ud7ff \ue000 \uffff \U00010000 \U0010ffff"
       not_escaped_string = '\u0000 \u0008 \u000c \U00000041 \u007f \u0080 \u00ff \ud7ff \ue000 \uffff \U00010000 \U0010ffff'

       basic_string = "~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø"
       literal_string = '~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø'

     output from parser-cmd (stdout):
       {
         "basic_string":   {"type": "string", "value": "~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø"},
         "literal_string": {"type": "string", "value": "~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø"},
         "escaped_string": {
           "type":  "string",
           "value": "\\u0000 \\u0008 \\u000c \\U00000041 \\u007f \\u0080 \\u00ff \\ud7ff \\ue000 \\uffff \\U00010000 \\U0010ffff"
         },
         "not_escaped_string": {
           "type":  "string",
           "value": "\\u0000 \\u0008 \\u000c \\U00000041 \\u007f \\u0080 \\u00ff \\ud7ff \\ue000 \\uffff \\U00010000 \\U0010ffff"
         }
       }

     want:
       {
           "basic_string":   {"type": "string", "value": "~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø"},
           "escaped_string": {"type": "string", "value": "\u0000 \b \f A  ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø"},
           "literal_string": {"type": "string", "value": "~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø"},
           "not_escaped_string": {
               "type":  "string",
               "value": "\\u0000 \\u0008 \\u000c \\U00000041 \\u007f \\u0080 \\u00ff \\ud7ff \\ue000 \\uffff \\U00010000 \\U0010ffff"
           }
       }

FAIL valid/string/raw-multiline
     invalid key
     invalid literal string
     unknown line
     expected '='
     expected value
     unknown line
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       # Single ' should be allowed.
       oneline = '''This string has a ' quote character.'''

       # A newline immediately following the opening delimiter will be trimmed.
       firstnl = '''
       This string has a ' quote character.'''

       # All other whitespace and newline characters remain intact.
       multiline = '''
       This string
       has ' a quote character
       and more than
       one newline
       in it.'''

       # Tab character in literal string does not need to be escaped
       multiline_with_tab = '''First line
       	 Followed by a tab'''

       this-str-has-apostrophes='''' there's one already
       '' two more
       '''''

     output from parser-cmd (stderr):
       invalid key
       invalid literal string
       unknown line
       expected '='
       expected value
       unknown line
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/string/start-mb
     Values for key "s3" don't match:
       Expected:     ¬ß
       Your encoder: \
     ¬ß

     input sent to parser-cmd:
       # Start first line with a multibyte character.
       #
       # https://github.com/marzer/tomlplusplus/issues/190
       s1 = "¬ß"
       s2 = '¬ß'
       s3 = """\
       ¬ß"""
       s4 = """
       ¬ß"""
       s5 = """¬ß"""
       s6 = '''
       ¬ß'''
       s7 = '''¬ß'''

     output from parser-cmd (stdout):
       {
         "s1": {"type": "string", "value": "¬ß"},
         "s2": {"type": "string", "value": "¬ß"},
         "s3": {"type": "string", "value": "\\\n¬ß"},
         "s4": {"type": "string", "value": "\n¬ß"},
         "s5": {"type": "string", "value": "¬ß"},
         "s6": {"type": "string", "value": "\n¬ß"},
         "s7": {"type": "string", "value": "¬ß"}
       }

     want:
       {
           "s1": {"type": "string", "value": "¬ß"},
           "s2": {"type": "string", "value": "¬ß"},
           "s3": {"type": "string", "value": "¬ß"},
           "s4": {"type": "string", "value": "¬ß"},
           "s5": {"type": "string", "value": "¬ß"},
           "s6": {"type": "string", "value": "¬ß"},
           "s7": {"type": "string", "value": "¬ß"}
       }

FAIL valid/string/unicode-escape
     Values for key "a" don't match:
       Expected:     a
       Your encoder: \u0061

     input sent to parser-cmd:
       delta-1 = "\u03B4"
       delta-2 = "\U000003B4"
       a       = "\u0061"
       b       = "\u0062"
       c       = "\U00000063"
       null-1  = "\u0000"
       null-2  = "\U00000000"

       ml-delta-1 = """\u03B4"""
       ml-delta-2 = """\U000003B4"""
       ml-a       = """\u0061"""
       ml-b       = """\u0062"""
       ml-c       = """\U00000063"""
       ml-null-1  = """\u0000"""
       ml-null-2  = """\U00000000"""

     output from parser-cmd (stdout):
       {
         "a":          {"type": "string", "value": "\\u0061"},
         "b":          {"type": "string", "value": "\\u0062"},
         "c":          {"type": "string", "value": "\\U00000063"},
         "delta-1":    {"type": "string", "value": "\\u03B4"},
         "delta-2":    {"type": "string", "value": "\\U000003B4"},
         "ml-a":       {"type": "string", "value": "\\u0061"},
         "ml-b":       {"type": "string", "value": "\\u0062"},
         "ml-c":       {"type": "string", "value": "\\U00000063"},
         "ml-delta-1": {"type": "string", "value": "\\u03B4"},
         "ml-delta-2": {"type": "string", "value": "\\U000003B4"},
         "ml-null-1":  {"type": "string", "value": "\\u0000"},
         "ml-null-2":  {"type": "string", "value": "\\U00000000"},
         "null-1":     {"type": "string", "value": "\\u0000"},
         "null-2":     {"type": "string", "value": "\\U00000000"}
       }

     want:
       {
           "a":          {"type": "string", "value": "a"},
           "b":          {"type": "string", "value": "b"},
           "c":          {"type": "string", "value": "c"},
           "delta-1":    {"type": "string", "value": "Œ¥"},
           "delta-2":    {"type": "string", "value": "Œ¥"},
           "ml-a":       {"type": "string", "value": "a"},
           "ml-b":       {"type": "string", "value": "b"},
           "ml-c":       {"type": "string", "value": "c"},
           "ml-delta-1": {"type": "string", "value": "Œ¥"},
           "ml-delta-2": {"type": "string", "value": "Œ¥"},
           "ml-null-1":  {"type": "string", "value": "\u0000"},
           "ml-null-2":  {"type": "string", "value": "\u0000"},
           "null-1":     {"type": "string", "value": "\u0000"},
           "null-2":     {"type": "string", "value": "\u0000"}
       }

FAIL valid/table/empty-name
     Could not find key "x" in parser output.

     input sent to parser-cmd:
       ['']
       x = 1

       ["".a]
       x = 2

       [a.'']
       x = 3

     output from parser-cmd (stdout):
       {
         "": {
           "a": {
             "x": {"type": "integer", "value": "2"}
           }
         },
         "a": {
           "": {
             "x": {"type": "integer", "value": "3"}
           }
         }
       }

     want:
       {
           "": {
               "x": {"type": "integer", "value": "1"},
               "a": {
                   "x": {"type": "integer", "value": "2"}
               }
           },
           "a": {
               "": {
                   "x": {"type": "integer", "value": "3"}
               }
           }
       }

FAIL valid/table/names
     Could not find key "x.1" in parser output.

     input sent to parser-cmd:
       [a.b.c]
       [a."b.c"]
       [a.'d.e']
       [a.' x ']
       [ d.e.f ]
       [ g . h . i ]
       [ j . " û" . 'l' ]

       [x.1.2]

     output from parser-cmd (stdout):
       {
         "a": {
           " x ": {},
           "b.c": {},
           "d.e": {},
           "b": {
             "c": {}
           }
         },
         "d": {
           "e": {
             "f": {}
           }
         },
         "g": {
           "h": {
             "i": {}
           }
         },
         "j": {
           " û": {
             "l": {}
           }
         },
         "x": {
           "1.2": {}
         }
       }

     want:
       {
           "a": {
               " x ": {},
               "b.c": {},
               "d.e": {},
               "b": {
                   "c": {}
               }
           },
           "d": {
               "e": {
                   "f": {}
               }
           },
           "g": {
               "h": {
                   "i": {}
               }
           },
           "j": {
               " û": {
                   "l": {}
               }
           },
           "x": {
               "1": {
                   "2": {}
               }
           }
       }

FAIL invalid/control/bare-cr
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       # The following line contains a single carriage return control character
       

     output from parser-cmd (stdout):
       {}

     want:
       Exit code 1

FAIL invalid/control/comment-cr
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       comment-cr   = "Carriage return in comment" # a=1

     output from parser-cmd (stdout):
       {
         "a":          {"type": "integer", "value": "1"},
         "comment-cr": {"type": "string", "value": "Carriage return in comment"}
       }

     want:
       Exit code 1

FAIL invalid/control/comment-del
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       comment-del  = "0x7f"   # 

     output from parser-cmd (stdout):
       {
         "comment-del": {"type": "string", "value": "0x7f"}
       }

     want:
       Exit code 1

FAIL invalid/control/comment-ff
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       comment-ff   = "0x7f"   # 

     output from parser-cmd (stdout):
       {
         "comment-ff": {"type": "string", "value": "0x7f"}
       }

     want:
       Exit code 1

FAIL invalid/control/comment-lf
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       comment-lf   = "ctrl-P" # 

     output from parser-cmd (stdout):
       {
         "comment-lf": {"type": "string", "value": "ctrl-P"}
       }

     want:
       Exit code 1

FAIL invalid/control/comment-null
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       comment-null = "null"   #  

     output from parser-cmd (stdout):
       {
         "comment-null": {"type": "string", "value": "null"}
       }

     want:
       Exit code 1

FAIL invalid/control/comment-us
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       comment-us   = "ctrl-_" # 

     output from parser-cmd (stdout):
       {
         "comment-us": {"type": "string", "value": "ctrl-_"}
       }

     want:
       Exit code 1

FAIL invalid/control/multi-cr
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       multi-cr   = """null"""

     output from parser-cmd (stdout):
       {
         "multi-cr": {"type": "string", "value": "null\r"}
       }

     want:
       Exit code 1

FAIL invalid/control/multi-del
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       multi-del  = """null"""

     output from parser-cmd (stdout):
       {
         "multi-del": {"type": "string", "value": "null"}
       }

     want:
       Exit code 1

FAIL invalid/control/multi-lf
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       multi-lf   = """null"""

     output from parser-cmd (stdout):
       {
         "multi-lf": {"type": "string", "value": "null\u0010"}
       }

     want:
       Exit code 1

FAIL invalid/control/multi-null
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       multi-null = """null """

     output from parser-cmd (stdout):
       {
         "multi-null": {"type": "string", "value": "null\u0000"}
       }

     want:
       Exit code 1

FAIL invalid/control/multi-us
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       multi-us   = """null"""

     output from parser-cmd (stdout):
       {
         "multi-us": {"type": "string", "value": "null\u001f"}
       }

     want:
       Exit code 1

FAIL invalid/control/rawmulti-cd
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       rawmulti-cd   = '''null'''

     output from parser-cmd (stdout):
       {
         "rawmulti-cd": {"type": "string", "value": "null\r"}
       }

     want:
       Exit code 1

FAIL invalid/control/rawmulti-del
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       rawmulti-del  = '''null'''

     output from parser-cmd (stdout):
       {
         "rawmulti-del": {"type": "string", "value": "null"}
       }

     want:
       Exit code 1

FAIL invalid/control/rawmulti-lf
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       rawmulti-lf   = '''null'''

     output from parser-cmd (stdout):
       {
         "rawmulti-lf": {"type": "string", "value": "null\u0010"}
       }

     want:
       Exit code 1

FAIL invalid/control/rawmulti-null
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       rawmulti-null = '''null '''

     output from parser-cmd (stdout):
       {
         "rawmulti-null": {"type": "string", "value": "null\u0000"}
       }

     want:
       Exit code 1

FAIL invalid/control/rawmulti-us
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       rawmulti-us   = '''null'''

     output from parser-cmd (stdout):
       {
         "rawmulti-us": {"type": "string", "value": "null\u001f"}
       }

     want:
       Exit code 1

FAIL invalid/control/rawstring-del
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       rawstring-del  = 'null'

     output from parser-cmd (stdout):
       {
         "rawstring-del": {"type": "string", "value": "null"}
       }

     want:
       Exit code 1

FAIL invalid/control/rawstring-lf
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       rawstring-lf   = 'null'

     output from parser-cmd (stdout):
       {
         "rawstring-lf": {"type": "string", "value": "null\u0010"}
       }

     want:
       Exit code 1

FAIL invalid/control/rawstring-null
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       rawstring-null = 'null '

     output from parser-cmd (stdout):
       {
         "rawstring-null": {"type": "string", "value": "null\u0000"}
       }

     want:
       Exit code 1

FAIL invalid/control/rawstring-us
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       rawstring-us   = 'null'

     output from parser-cmd (stdout):
       {
         "rawstring-us": {"type": "string", "value": "null\u001f"}
       }

     want:
       Exit code 1

FAIL invalid/control/string-bs
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       string-bs   = "backspace"

     output from parser-cmd (stdout):
       {
         "string-bs": {"type": "string", "value": "backspace\b"}
       }

     want:
       Exit code 1

FAIL invalid/control/string-del
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       string-del  = "null"

     output from parser-cmd (stdout):
       {
         "string-del": {"type": "string", "value": "null"}
       }

     want:
       Exit code 1

FAIL invalid/control/string-lf
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       string-lf   = "null"

     output from parser-cmd (stdout):
       {
         "string-lf": {"type": "string", "value": "null\u0010"}
       }

     want:
       Exit code 1

FAIL invalid/control/string-null
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       string-null = "null "

     output from parser-cmd (stdout):
       {
         "string-null": {"type": "string", "value": "null\u0000"}
       }

     want:
       Exit code 1

FAIL invalid/control/string-us
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       string-us   = "null"

     output from parser-cmd (stdout):
       {
         "string-us": {"type": "string", "value": "null\u001f"}
       }

     want:
       Exit code 1

FAIL invalid/inline-table/duplicate-key-3
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       tbl = { fruit = { apple.color = "red" }, fruit.apple.texture = { smooth = true } }

     output from parser-cmd (stdout):
       {
         "tbl": {
           "fruit": {
             "apple": {
               "color": {"type": "string", "value": "red"},
               "texture": {
                 "smooth": {"type": "bool", "value": "true"}
               }
             }
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/inline-table/overwrite-01
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       a.b=0
       # Since table "a" is already defined, it can't be replaced by an inline table.
       a={}

     output from parser-cmd (stdout):
       {
         "a": {
           "b": {"type": "integer", "value": "0"}
         }
       }

     want:
       Exit code 1

FAIL invalid/inline-table/overwrite-02
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       a={}
       # Inline tables are immutable and can't be extended
       [a.b]

     output from parser-cmd (stdout):
       {
         "a": {
           "b": {}
         }
       }

     want:
       Exit code 1

FAIL invalid/inline-table/overwrite-05
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       inline-t = { nest = {} }

       [inline-t.nest]

     output from parser-cmd (stdout):
       {
         "inline-t": {
           "nest": {}
         }
       }

     want:
       Exit code 1

FAIL invalid/inline-table/overwrite-08
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       tab = { inner = { dog = "best" }, inner.cat = "worst" }

     output from parser-cmd (stdout):
       {
         "tab": {
           "inner": {
             "cat": {"type": "string", "value": "worst"},
             "dog": {"type": "string", "value": "best"}
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/key/after-array
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [[agencies]] owner = "S Cjelli"

     output from parser-cmd (stdout):
       {
         "agencies": [{
           "owner": {"type": "string", "value": "S Cjelli"}
         }]
       }

     want:
       Exit code 1

FAIL invalid/key/after-table
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [error] this = "should not be here"

     output from parser-cmd (stdout):
       {
         "error": {
           "this": {"type": "string", "value": "should not be here"}
         }
       }

     want:
       Exit code 1

FAIL invalid/key/after-value
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       first = "Tom" last = "Preston-Werner" # INVALID

     output from parser-cmd (stdout):
       {
         "first": {"type": "string", "value": "Tom"},
         "last":  {"type": "string", "value": "Preston-Werner"}
       }

     want:
       Exit code 1

FAIL invalid/key/duplicate-keys-3
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       spelling   = "favorite"
       "spelling" = "favourite"

     output from parser-cmd (stdout):
       {
         "spelling": {"type": "string", "value": "favourite"}
       }

     want:
       Exit code 1

FAIL invalid/key/duplicate-keys-4
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       spelling   = "favorite"
       'spelling' = "favourite"

     output from parser-cmd (stdout):
       {
         "spelling": {"type": "string", "value": "favourite"}
       }

     want:
       Exit code 1

FAIL invalid/key/no-eol
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       a = 1 b = 2

     output from parser-cmd (stdout):
       {
         "a": {"type": "integer", "value": "1"},
         "b": {"type": "integer", "value": "2"}
       }

     want:
       Exit code 1

FAIL invalid/local-datetime/no-secs
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       # No seconds in time.
       no-secs = 1987-07-05T17:45

     output from parser-cmd (stdout):
       {
         "no-secs": {"type": "datetime-local", "value": "1987-07-05T17:45"}
       }

     want:
       Exit code 1

FAIL invalid/local-time/no-secs
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       # No seconds in time.
       no-secs = 17:45

     output from parser-cmd (stdout):
       {
         "no-secs": {"type": "time-local", "value": "17:45"}
       }

     want:
       Exit code 1

FAIL invalid/spec/inline-table-2-0
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [product]
       type = { name = "Nail" }
       type.edible = false  # INVALID

     output from parser-cmd (stdout):
       {
         "product": {
           "type": {
             "edible": {"type": "bool", "value": "false"},
             "name":   {"type": "string", "value": "Nail"}
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/spec/inline-table-3-0
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [product]
       type.name = "Nail"
       type = { edible = false }  # INVALID

     output from parser-cmd (stdout):
       {
         "product": {
           "type": {
             "edible": {"type": "bool", "value": "false"},
             "name":   {"type": "string", "value": "Nail"}
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/spec/table-9-0
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [fruit]
       apple.color = "red"
       apple.taste.sweet = true

       [fruit.apple]  # INVALID
       # [fruit.apple.taste]  # INVALID

       [fruit.apple.texture]  # you can add sub-tables
       smooth = true

     output from parser-cmd (stdout):
       {
         "fruit": {
           "apple": {
             "color": {"type": "string", "value": "red"},
             "taste": {
               "sweet": {"type": "bool", "value": "true"}
             },
             "texture": {
               "smooth": {"type": "bool", "value": "true"}
             }
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/spec/table-9-1
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [fruit]
       apple.color = "red"
       apple.taste.sweet = true

       # [fruit.apple]  # INVALID
       [fruit.apple.taste]  # INVALID

       [fruit.apple.texture]  # you can add sub-tables
       smooth = true

     output from parser-cmd (stdout):
       {
         "fruit": {
           "apple": {
             "color": {"type": "string", "value": "red"},
             "taste": {
               "sweet": {"type": "bool", "value": "true"}
             },
             "texture": {
               "smooth": {"type": "bool", "value": "true"}
             }
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/string/bad-byte-escape
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       naughty = "\xAg"

     output from parser-cmd (stdout):
       {
         "naughty": {"type": "string", "value": "\\xAg"}
       }

     want:
       Exit code 1

FAIL invalid/string/bad-escape-1
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       invalid-escape = "This string has a bad \a escape character."

     output from parser-cmd (stdout):
       {
         "invalid-escape": {"type": "string", "value": "This string has a bad \\a escape character."}
       }

     want:
       Exit code 1

FAIL invalid/string/bad-escape-2
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       invalid-escape = "This string has a bad \  escape character."

     output from parser-cmd (stdout):
       {
         "invalid-escape": {"type": "string", "value": "This string has a bad \\  escape character."}
       }

     want:
       Exit code 1

FAIL invalid/string/bad-hex-esc-1
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       bad-hex-esc-1 = "\x0g"

     output from parser-cmd (stdout):
       {
         "bad-hex-esc-1": {"type": "string", "value": "\\x0g"}
       }

     want:
       Exit code 1

FAIL invalid/string/bad-hex-esc-2
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       bad-hex-esc-2 = "\xG0"

     output from parser-cmd (stdout):
       {
         "bad-hex-esc-2": {"type": "string", "value": "\\xG0"}
       }

     want:
       Exit code 1

FAIL invalid/string/bad-hex-esc-3
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       bad-hex-esc-3 = "\x"

     output from parser-cmd (stdout):
       {
         "bad-hex-esc-3": {"type": "string", "value": "\\x"}
       }

     want:
       Exit code 1

FAIL invalid/string/bad-hex-esc-4
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       bad-hex-esc-4 = "\x 50"

     output from parser-cmd (stdout):
       {
         "bad-hex-esc-4": {"type": "string", "value": "\\x 50"}
       }

     want:
       Exit code 1

FAIL invalid/string/bad-hex-esc-5
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       bad-hex-esc-5 = "\x 50"

     output from parser-cmd (stdout):
       {
         "bad-hex-esc-5": {"type": "string", "value": "\\x 50"}
       }

     want:
       Exit code 1

FAIL invalid/string/bad-slash-escape
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       invalid-escape = "This string has a bad \/ escape character."

     output from parser-cmd (stdout):
       {
         "invalid-escape": {"type": "string", "value": "This string has a bad \\/ escape character."}
       }

     want:
       Exit code 1

FAIL invalid/string/bad-uni-esc-1
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       bad-uni-esc-1 = "val\ue"

     output from parser-cmd (stdout):
       {
         "bad-uni-esc-1": {"type": "string", "value": "val\\ue"}
       }

     want:
       Exit code 1

FAIL invalid/string/bad-uni-esc-2
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       bad-uni-esc-2 = "val\Ux"

     output from parser-cmd (stdout):
       {
         "bad-uni-esc-2": {"type": "string", "value": "val\\Ux"}
       }

     want:
       Exit code 1

FAIL invalid/string/bad-uni-esc-3
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       bad-uni-esc-3 = "val\U0000000"

     output from parser-cmd (stdout):
       {
         "bad-uni-esc-3": {"type": "string", "value": "val\\U0000000"}
       }

     want:
       Exit code 1

FAIL invalid/string/bad-uni-esc-4
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       bad-uni-esc-4 = "val\U0000"

     output from parser-cmd (stdout):
       {
         "bad-uni-esc-4": {"type": "string", "value": "val\\U0000"}
       }

     want:
       Exit code 1

FAIL invalid/string/bad-uni-esc-5
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       bad-uni-esc-5 = "val\Ugggggggg"

     output from parser-cmd (stdout):
       {
         "bad-uni-esc-5": {"type": "string", "value": "val\\Ugggggggg"}
       }

     want:
       Exit code 1

FAIL invalid/string/bad-uni-esc-6
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       bad-uni-esc-6 = "This string contains a non scalar unicode codepoint \uD801"

     output from parser-cmd (stdout):
       {
         "bad-uni-esc-6": {"type": "string", "value": "This string contains a non scalar unicode codepoint \\uD801"}
       }

     want:
       Exit code 1

FAIL invalid/string/bad-uni-esc-7
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       bad-uni-esc-7 = "\uabag"

     output from parser-cmd (stdout):
       {
         "bad-uni-esc-7": {"type": "string", "value": "\\uabag"}
       }

     want:
       Exit code 1

FAIL invalid/string/basic-byte-escapes
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       answer = "\x33"

     output from parser-cmd (stdout):
       {
         "answer": {"type": "string", "value": "\\x33"}
       }

     want:
       Exit code 1

FAIL invalid/string/basic-multiline-out-of-range-unicode-escape-1
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       a = """\UFFFFFFFF"""

     output from parser-cmd (stdout):
       {
         "a": {"type": "string", "value": "\\UFFFFFFFF"}
       }

     want:
       Exit code 1

FAIL invalid/string/basic-multiline-out-of-range-unicode-escape-2
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       a = """\U00D80000"""

     output from parser-cmd (stdout):
       {
         "a": {"type": "string", "value": "\\U00D80000"}
       }

     want:
       Exit code 1

FAIL invalid/string/basic-multiline-unknown-escape
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       a = """\@"""

     output from parser-cmd (stdout):
       {
         "a": {"type": "string", "value": "\\@"}
       }

     want:
       Exit code 1

FAIL invalid/string/basic-out-of-range-unicode-escape-1
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       a = "\UFFFFFFFF"

     output from parser-cmd (stdout):
       {
         "a": {"type": "string", "value": "\\UFFFFFFFF"}
       }

     want:
       Exit code 1

FAIL invalid/string/basic-out-of-range-unicode-escape-2
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       a = "\U00D80000"

     output from parser-cmd (stdout):
       {
         "a": {"type": "string", "value": "\\U00D80000"}
       }

     want:
       Exit code 1

FAIL invalid/string/basic-unknown-escape
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       a = "\@"

     output from parser-cmd (stdout):
       {
         "a": {"type": "string", "value": "\\@"}
       }

     want:
       Exit code 1

FAIL invalid/string/multiline-bad-escape-1
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       k = """t\a"""

     output from parser-cmd (stdout):
       {
         "k": {"type": "string", "value": "t\\a"}
       }

     want:
       Exit code 1

FAIL invalid/string/multiline-bad-escape-2
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       # \<Space> is not a valid escape.
       k = """t\ t"""

     output from parser-cmd (stdout):
       {
         "k": {"type": "string", "value": "t\\ t"}
       }

     want:
       Exit code 1

FAIL invalid/string/multiline-bad-escape-3
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       # \<Space> is not a valid escape.
       k = """t\ """

     output from parser-cmd (stdout):
       {
         "k": {"type": "string", "value": "t\\ "}
       }

     want:
       Exit code 1

FAIL invalid/string/multiline-bad-escape-4
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       backslash = """\"""

     output from parser-cmd (stdout):
       {
         "backslash": {"type": "string", "value": "\\"}
       }

     want:
       Exit code 1

FAIL invalid/string/multiline-escape-space-1
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       a = """
         foo \ \n
         bar"""

     output from parser-cmd (stdout):
       {
         "a": {"type": "string", "value": "\n  foo \\ \\n\n  bar"}
       }

     want:
       Exit code 1

FAIL invalid/string/multiline-escape-space-2
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       bee = """
       hee \

       gee \   """

     output from parser-cmd (stdout):
       {
         "bee": {"type": "string", "value": "\nhee \\\n\ngee \\   "}
       }

     want:
       Exit code 1

FAIL invalid/table/append-with-dotted-keys-1
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       # First a.b.c defines a table: a.b.c = {z=9}
       #
       # Then we define a.b.c.t = "str" to add a str to the above table, making it:
       #
       #   a.b.c = {z=9, t="..."}
       #
       # While this makes sense, logically, it was decided this is not valid TOML as
       # it's too confusing/convoluted.
       #
       # See: https://github.com/toml-lang/toml/issues/846
       #      https://github.com/toml-lang/toml/pull/859

       [a.b.c]
         z = 9

       [a]
         b.c.t = "Using dotted keys to add to [a.b.c] after explicitly defining it above is not allowed"

     output from parser-cmd (stdout):
       {
         "a": {
           "b": {
             "c": {
               "z": {"type": "integer", "value": "9"},
               "t": {
                 "type":  "string",
                 "value": "Using dotted keys to add to [a.b.c] after explicitly defining it above is not allowed"
               }
             }
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/table/append-with-dotted-keys-2
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       # This is the same issue as in injection-1.toml, except that nests one level
       # deeper. See that file for a more complete description.

       [a.b.c.d]
         z = 9

       [a]
         b.c.d.k.t = "Using dotted keys to add to [a.b.c.d] after explicitly defining it above is not allowed"

     output from parser-cmd (stdout):
       {
         "a": {
           "b": {
             "c": {
               "d": {
                 "z": {"type": "integer", "value": "9"},
                 "k": {
                   "t": {
                     "type":  "string",
                     "value": "Using dotted keys to add to [a.b.c.d] after explicitly defining it above is not allowed"
                   }
                 }
               }
             }
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/table/duplicate
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [a]
       b = 1

       [a]
       c = 2

     output from parser-cmd (stdout):
       {
         "a": {
           "b": {"type": "integer", "value": "1"},
           "c": {"type": "integer", "value": "2"}
         }
       }

     want:
       Exit code 1

FAIL invalid/table/duplicate-key-dotted-table
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [fruit]
       apple.color = "red"

       [fruit.apple] # INVALID

     output from parser-cmd (stdout):
       {
         "fruit": {
           "apple": {
             "color": {"type": "string", "value": "red"}
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/table/duplicate-key-dotted-table2
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [fruit]
       apple.taste.sweet = true

       [fruit.apple.taste] # INVALID

     output from parser-cmd (stdout):
       {
         "fruit": {
           "apple": {
             "taste": {
               "sweet": {"type": "bool", "value": "true"}
             }
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/table/redefine-2
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [t1]
       t2.t3.v = 0
       [t1.t2]

     output from parser-cmd (stdout):
       {
         "t1": {
           "t2": {
             "t3": {
               "v": {"type": "integer", "value": "0"}
             }
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/table/redefine-3
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [t1]
       t2.t3.v = 0
       [t1.t2.t3]

     output from parser-cmd (stdout):
       {
         "t1": {
           "t2": {
             "t3": {
               "v": {"type": "integer", "value": "0"}
             }
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/table/super-twice
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [a.b]
       [a]
       [a]

     output from parser-cmd (stdout):
       {
         "a": {
           "b": {}
         }
       }

     want:
       Exit code 1

toml-test v0001-01-01 [/Users/s23467/develop/tombi/target/debug/decode --toml-version v1.0.0]: using embedded tests
  valid tests: 149 passed, 33 failed
invalid tests: 291 passed, 80 failed
