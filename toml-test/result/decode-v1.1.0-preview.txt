FAIL valid/key/numeric-dotted
     Could not find key "1" in parser output.

     input sent to parser-cmd:
       1.2 = 3

     output from parser-cmd (stdout):
       {
         "1.2": {"type": "integer", "value": "3"}
       }

     want:
       {
           "1": {
               "2": {"type": "integer", "value": "3"}
           }
       }

FAIL valid/key/quoted-unicode
     duplicate key: '\u0000'
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:

       "\u0000" = "null"
       '\u0000' = "different key"
       "\u0008 \u000c \U00000041 \u007f \u0080 \u00ff \ud7ff \ue000 \uffff \U00010000 \U0010ffff" = "escaped key"

       "~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø" = "basic key"
       'l ~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø' = "literal key"

     output from parser-cmd (stderr):
       duplicate key: '\u0000'
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/key/start
     invalid token
     invalid token
     invalid token
     invalid token
     invalid token
     invalid token
     invalid token
     invalid token
     expected key
     expected ']'
     expected key
     expected '='
     expected value
     expected key
     expected ']'
     expected key
     expected '='
     expected value
     expected key
     expected ']'
     expected key
     expected '='
     expected value
     expected key
     expected '='
     expected value
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       # Table and keys can start with any character; there is no requirement for it to
       # start with a letter.

       [-key]
       -key = 1

       [_key]
       _key = 2

       [1key]
       1key = 3

       [-]
       - = 4

       [_]
       _ = 5

       [1]
       1 = 6

       [---]
       --- = 7

       [___]
       ___ = 8

       [111]
       111 = 9

       [inline]
       --- = {--- = 10, ___ = 11, 111 = 12}

     output from parser-cmd (stderr):
       invalid token
       invalid token
       invalid token
       invalid token
       invalid token
       invalid token
       invalid token
       invalid token
       expected key
       expected ']'
       expected key
       expected '='
       expected value
       expected key
       expected ']'
       expected key
       expected '='
       expected value
       expected key
       expected ']'
       expected key
       expected '='
       expected value
       expected key
       expected '='
       expected value
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/key/unicode
     invalid token
     invalid token
     invalid key
     invalid token
     invalid token
     invalid token
     invalid token
     invalid key
     invalid key
     invalid key
     invalid key
     invalid key
     invalid key
     unknown line
     unknown line
     unknown line
     unknown line
     expected key
     expected ']'
     expected key
     expected '='
     expected value
     expected key
     expected ']]'
     expected key
     expected '='
     expected value
     expected key
     expected ']]'
     expected key
     expected '='
     expected value
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       # TOML 1.1 supports Unicode for bare keys.

       ‚Ç¨ = 'Euro'
       üòÇ = "rofl"
       a‚Äçb = "zwj"
       √ÖAÃä = "U+00C5 U+0041 U+030A"

       [‰∏≠Êñá]
       ‰∏≠Êñá = {‰∏≠Êñá = "Chinese language"}

       [[ti·∫øng-Vi·ªát]]
       ti…ô≈ãÀßÀ¶.vi…ôtÃöÀßÀ® î = "north"

       [[ti·∫øng-Vi·ªát]]
       ti…ô≈ãÀ¶ÀßÀ•.vi…ôkÃöÀ®À© î = "central"

     output from parser-cmd (stderr):
       invalid token
       invalid token
       invalid key
       invalid token
       invalid token
       invalid token
       invalid token
       invalid key
       invalid key
       invalid key
       invalid key
       invalid key
       invalid key
       unknown line
       unknown line
       unknown line
       unknown line
       expected key
       expected ']'
       expected key
       expected '='
       expected value
       expected key
       expected ']]'
       expected key
       expected '='
       expected value
       expected key
       expected ']]'
       expected key
       expected '='
       expected value
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/spec/keys-7
     Could not find key "3" in parser output.

     input sent to parser-cmd:
       3.14159 = "pi"

     output from parser-cmd (stdout):
       {
         "3.14159": {"type": "string", "value": "pi"}
       }

     want:
       {
           "3": {
               "14159": {"type": "string", "value": "pi"}
           }
       }

FAIL valid/spec/string-4
     invalid token
     invalid multi-line basic strings
     unknown line
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       str4 = """Here are two quotation marks: "". Simple enough."""
       # str5 = """Here are three quotation marks: """."""  # INVALID
       str5 = """Here are three quotation marks: ""\"."""
       str6 = """Here are fifteen quotation marks: ""\"""\"""\"""\"""\"."""

       # "This," she said, "is just a pointless statement."
       str7 = """"This," she said, "is just a pointless statement.""""

     output from parser-cmd (stderr):
       invalid token
       invalid multi-line basic strings
       unknown line
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/spec/string-5
     invalid key
     expected '='
     unknown line
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       # What you see is what you get.
       winpath  = 'C:\Users\nodejs\templates'
       winpath2 = '\\ServerX\admin$\system32\'
       quoted   = 'Tom "Dubs" Preston-Werner'
       regex    = '<\i\c*\s*>'

     output from parser-cmd (stderr):
       invalid key
       expected '='
       unknown line
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/spec/string-6
     invalid string: invalid escape sequence
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       regex2 = '''I [dw]on't need \d{2} apples'''
       lines  = '''
       The first newline is
       trimmed in raw strings.
          All other whitespace
          is preserved.
       '''

     output from parser-cmd (stderr):
       invalid string: invalid escape sequence
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/spec/string-7
     expected '='
     expected value
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       quot15 = '''Here are fifteen quotation marks: """""""""""""""'''

       # apos15 = '''Here are fifteen apostrophes: ''''''''''''''''''  # INVALID
       apos15 = "Here are fifteen apostrophes: '''''''''''''''"

       # 'That,' she said, 'is still pointless.'
       str = ''''That,' she said, 'is still pointless.''''

     output from parser-cmd (stderr):
       expected '='
       expected value
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/string/ends-in-whitespace-escape
     invalid string: invalid escape sequence
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       beee = """
       heeee
       geeee\


             """

     output from parser-cmd (stderr):
       invalid string: invalid escape sequence
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/string/escape-esc
     invalid string: invalid escape sequence
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       esc = "\e There is no escape! \e"

     output from parser-cmd (stderr):
       invalid string: invalid escape sequence
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/string/escape-tricky
     invalid basic string
     invalid token
     invalid key
     expected value
     unknown line
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       end_esc = "String does not end here\" but ends here\\"
       lit_end_esc = 'String ends here\'

       multiline_unicode = """
       \u00a0"""

       multiline_not_unicode = """
       \\u0041"""

       multiline_end_esc = """When will it end? \"""...""\" should be here\""""

       lit_multiline_not_unicode = '''
       \u007f'''

       lit_multiline_end = '''There is no escape\'''

     output from parser-cmd (stderr):
       invalid basic string
       invalid token
       invalid key
       expected value
       unknown line
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/string/hex-escape
     invalid string: invalid escape sequence
     invalid string: invalid escape sequence
     invalid string: invalid escape sequence
     invalid string: invalid escape sequence
     invalid string: invalid escape sequence
     invalid string: invalid escape sequence
     invalid string: invalid escape sequence
     invalid string: invalid escape sequence
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       # \x for the first 255 codepoints

       whitespace      = "\x20 \x09 \x1b \x0d\x0a"
       bs              = "\x7f"
       nul             = "\x00"
       hello           = "\x68\x65\x6c\x6c\x6f\x0a"
       higher-than-127 = "S\xf8rmirb\xe6ren"

       multiline = """
       \x20 \x09 \x1b \x0d\x0a
       \x7f
       \x00
       \x68\x65\x6c\x6c\x6f\x0a
       \x53\xF8\x72\x6D\x69\x72\x62\xE6\x72\x65\x6E
       """

       # Not inside literals.
       literal = '\x20 \x09 \x0d\x0a'
       multiline-literal = '''
       \x20 \x09 \x0d\x0a
       '''

     output from parser-cmd (stderr):
       invalid string: invalid escape sequence
       invalid string: invalid escape sequence
       invalid string: invalid escape sequence
       invalid string: invalid escape sequence
       invalid string: invalid escape sequence
       invalid string: invalid escape sequence
       invalid string: invalid escape sequence
       invalid string: invalid escape sequence
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/string/multiline
     invalid string: invalid escape sequence
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       # NOTE: this file includes some literal tab characters.

       equivalent_one = "The quick brown fox jumps over the lazy dog."
       equivalent_two = """
       The quick brown \


         fox jumps over \
           the lazy dog."""

       equivalent_three = """\
              The quick brown \
              fox jumps over \
              the lazy dog.\
              """

       whitespace-after-bs = """\
              The quick brown \
              fox jumps over \
              the lazy dog.\
              """

       no-space = """a\
           b"""

       # Has tab character.
       keep-ws-before = """a   	\
          b"""

       escape-bs-1 = """a \\
       b"""

       escape-bs-2 = """a \\\
       b"""

       escape-bs-3 = """a \\\\
         b"""

     output from parser-cmd (stderr):
       invalid string: invalid escape sequence
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/string/multiline-empty
     expected '='
     expected value
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       empty-1 = """"""

       # A newline immediately following the opening delimiter will be trimmed.
       empty-2 = """
       """

       # \ at the end of line trims newlines as well; note that last \ is followed by
       # two spaces, which are ignored.
       empty-3 = """\
           """
       empty-4 = """\
          \
          \
          """

     output from parser-cmd (stderr):
       expected '='
       expected value
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/string/multiline-quotes
     invalid key
     invalid key
     expected '='
     expected value
     expected '='
     expected '='
     expected value
     expected '='
     unknown line
     expected '='
     expected value
     unknown line
     expected '='
     expected value
     unknown line
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       # Make sure that quotes inside multiline strings are allowed, including right
       # after the opening '''/""" and before the closing '''/"""

       lit_one = ''''one quote''''
       lit_two = '''''two quotes'''''
       lit_one_space = ''' 'one quote' '''
       lit_two_space = ''' ''two quotes'' '''

       one = """"one quote""""
       two = """""two quotes"""""
       one_space = """ "one quote" """
       two_space = """ ""two quotes"" """

       mismatch1 = """aaa'''bbb"""
       mismatch2 = '''aaa"""bbb'''

       # Three opening """, then one escaped ", then two "" (allowed), and then three
       # closing """
       escaped = """lol\""""""

       five-quotes = """
       Closing with five quotes
       """""
       four-quotes = """
       Closing with four quotes
       """"

     output from parser-cmd (stderr):
       invalid key
       invalid key
       expected '='
       expected value
       expected '='
       expected '='
       expected value
       expected '='
       unknown line
       expected '='
       expected value
       unknown line
       expected '='
       expected value
       unknown line
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/string/nl
     invalid string: invalid Unicode escape sequence
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       nl_mid = "val\nue"
       nl_end = """value\n"""

       lit_nl_end = '''value\n'''
       lit_nl_mid = 'val\nue'
       lit_nl_uni = 'val\ue'

     output from parser-cmd (stderr):
       invalid string: invalid Unicode escape sequence
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/string/quoted-unicode
     Values for key "not_escaped_string" don't match:
       Expected:     \u0000 \u0008 \u000c \U00000041 \u007f \u0080 \u00ff \ud7ff \ue000 \uffff \U00010000 \U0010ffff
       Your encoder:     A  ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø

     input sent to parser-cmd:

       escaped_string = "\u0000 \u0008 \u000c \U00000041 \u007f \u0080 \u00ff \ud7ff \ue000 \uffff \U00010000 \U0010ffff"
       not_escaped_string = '\u0000 \u0008 \u000c \U00000041 \u007f \u0080 \u00ff \ud7ff \ue000 \uffff \U00010000 \U0010ffff'

       basic_string = "~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø"
       literal_string = '~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø'

     output from parser-cmd (stdout):
       {
         "basic_string":       {"type": "string", "value": "~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø"},
         "escaped_string":     {"type": "string", "value": "\u0000 \b \f A  ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø"},
         "literal_string":     {"type": "string", "value": "~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø"},
         "not_escaped_string": {"type": "string", "value": "\u0000 \b \f A  ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø"}
       }

     want:
       {
           "basic_string":   {"type": "string", "value": "~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø"},
           "escaped_string": {"type": "string", "value": "\u0000 \b \f A  ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø"},
           "literal_string": {"type": "string", "value": "~ ¬Ä √ø Ìüø ÓÄÄ Ôøø êÄÄ Ùèøø"},
           "not_escaped_string": {
               "type":  "string",
               "value": "\\u0000 \\u0008 \\u000c \\U00000041 \\u007f \\u0080 \\u00ff \\ud7ff \\ue000 \\uffff \\U00010000 \\U0010ffff"
           }
       }

FAIL valid/string/raw
     invalid string: invalid escape sequence
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       backspace = 'This string has a \b backspace character.'
       tab = 'This string has a \t tab character.'
       unescaped_tab = 'This string has an 	 unescaped tab character.'
       newline = 'This string has a \n new line character.'
       formfeed = 'This string has a \f form feed character.'
       carriage = 'This string has a \r carriage return character.'
       slash = 'This string has a \/ slash character.'
       backslash = 'This string has a \\ backslash character.'

     output from parser-cmd (stderr):
       invalid string: invalid escape sequence
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/string/raw-multiline
     invalid key
     invalid literal string
     unknown line
     expected '='
     expected value
     unknown line
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       # Single ' should be allowed.
       oneline = '''This string has a ' quote character.'''

       # A newline immediately following the opening delimiter will be trimmed.
       firstnl = '''
       This string has a ' quote character.'''

       # All other whitespace and newline characters remain intact.
       multiline = '''
       This string
       has ' a quote character
       and more than
       one newline
       in it.'''

       # Tab character in literal string does not need to be escaped
       multiline_with_tab = '''First line
       	 Followed by a tab'''

       this-str-has-apostrophes='''' there's one already
       '' two more
       '''''

     output from parser-cmd (stderr):
       invalid key
       invalid literal string
       unknown line
       expected '='
       expected value
       unknown line
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/table/names
     Could not find key "x.1" in parser output.

     input sent to parser-cmd:
       [a.b.c]
       [a."b.c"]
       [a.'d.e']
       [a.' x ']
       [ d.e.f ]
       [ g . h . i ]
       [ j . " û" . 'l' ]

       [x.1.2]

     output from parser-cmd (stdout):
       {
         "a": {
           " x ": {},
           "b.c": {},
           "d.e": {},
           "b": {
             "c": {}
           }
         },
         "d": {
           "e": {
             "f": {}
           }
         },
         "g": {
           "h": {
             "i": {}
           }
         },
         "j": {
           " û": {
             "l": {}
           }
         },
         "x": {
           "1.2": {}
         }
       }

     want:
       {
           "a": {
               " x ": {},
               "b.c": {},
               "d.e": {},
               "b": {
                   "c": {}
               }
           },
           "d": {
               "e": {
                   "f": {}
               }
           },
           "g": {
               "h": {
                   "i": {}
               }
           },
           "j": {
               " û": {
                   "l": {}
               }
           },
           "x": {
               "1": {
                   "2": {}
               }
           }
       }

FAIL invalid/control/bare-cr
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       # The following line contains a single carriage return control character
       

     output from parser-cmd (stdout):
       {}

     want:
       Exit code 1

FAIL invalid/control/comment-cr
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       comment-cr   = "Carriage return in comment" # a=1

     output from parser-cmd (stdout):
       {
         "a":          {"type": "integer", "value": "1"},
         "comment-cr": {"type": "string", "value": "Carriage return in comment"}
       }

     want:
       Exit code 1

FAIL invalid/control/comment-del
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       comment-del  = "0x7f"   # 

     output from parser-cmd (stdout):
       {
         "comment-del": {"type": "string", "value": "0x7f"}
       }

     want:
       Exit code 1

FAIL invalid/control/comment-ff
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       comment-ff   = "0x7f"   # 

     output from parser-cmd (stdout):
       {
         "comment-ff": {"type": "string", "value": "0x7f"}
       }

     want:
       Exit code 1

FAIL invalid/control/comment-lf
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       comment-lf   = "ctrl-P" # 

     output from parser-cmd (stdout):
       {
         "comment-lf": {"type": "string", "value": "ctrl-P"}
       }

     want:
       Exit code 1

FAIL invalid/control/comment-null
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       comment-null = "null"   #  

     output from parser-cmd (stdout):
       {
         "comment-null": {"type": "string", "value": "null"}
       }

     want:
       Exit code 1

FAIL invalid/control/comment-us
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       comment-us   = "ctrl-_" # 

     output from parser-cmd (stdout):
       {
         "comment-us": {"type": "string", "value": "ctrl-_"}
       }

     want:
       Exit code 1

FAIL invalid/control/multi-cr
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       multi-cr   = """null"""

     output from parser-cmd (stdout):
       {
         "multi-cr": {"type": "string", "value": "null\r"}
       }

     want:
       Exit code 1

FAIL invalid/control/multi-del
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       multi-del  = """null"""

     output from parser-cmd (stdout):
       {
         "multi-del": {"type": "string", "value": "null"}
       }

     want:
       Exit code 1

FAIL invalid/control/multi-lf
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       multi-lf   = """null"""

     output from parser-cmd (stdout):
       {
         "multi-lf": {"type": "string", "value": "null\u0010"}
       }

     want:
       Exit code 1

FAIL invalid/control/multi-null
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       multi-null = """null """

     output from parser-cmd (stdout):
       {
         "multi-null": {"type": "string", "value": "null\u0000"}
       }

     want:
       Exit code 1

FAIL invalid/control/multi-us
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       multi-us   = """null"""

     output from parser-cmd (stdout):
       {
         "multi-us": {"type": "string", "value": "null\u001f"}
       }

     want:
       Exit code 1

FAIL invalid/control/rawmulti-cd
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       rawmulti-cd   = '''null'''

     output from parser-cmd (stdout):
       {
         "rawmulti-cd": {"type": "string", "value": "null\r"}
       }

     want:
       Exit code 1

FAIL invalid/control/rawmulti-del
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       rawmulti-del  = '''null'''

     output from parser-cmd (stdout):
       {
         "rawmulti-del": {"type": "string", "value": "null"}
       }

     want:
       Exit code 1

FAIL invalid/control/rawmulti-lf
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       rawmulti-lf   = '''null'''

     output from parser-cmd (stdout):
       {
         "rawmulti-lf": {"type": "string", "value": "null\u0010"}
       }

     want:
       Exit code 1

FAIL invalid/control/rawmulti-null
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       rawmulti-null = '''null '''

     output from parser-cmd (stdout):
       {
         "rawmulti-null": {"type": "string", "value": "null\u0000"}
       }

     want:
       Exit code 1

FAIL invalid/control/rawmulti-us
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       rawmulti-us   = '''null'''

     output from parser-cmd (stdout):
       {
         "rawmulti-us": {"type": "string", "value": "null\u001f"}
       }

     want:
       Exit code 1

FAIL invalid/control/rawstring-del
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       rawstring-del  = 'null'

     output from parser-cmd (stdout):
       {
         "rawstring-del": {"type": "string", "value": "null"}
       }

     want:
       Exit code 1

FAIL invalid/control/rawstring-lf
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       rawstring-lf   = 'null'

     output from parser-cmd (stdout):
       {
         "rawstring-lf": {"type": "string", "value": "null\u0010"}
       }

     want:
       Exit code 1

FAIL invalid/control/rawstring-null
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       rawstring-null = 'null '

     output from parser-cmd (stdout):
       {
         "rawstring-null": {"type": "string", "value": "null\u0000"}
       }

     want:
       Exit code 1

FAIL invalid/control/rawstring-us
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       rawstring-us   = 'null'

     output from parser-cmd (stdout):
       {
         "rawstring-us": {"type": "string", "value": "null\u001f"}
       }

     want:
       Exit code 1

FAIL invalid/control/string-bs
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       string-bs   = "backspace"

     output from parser-cmd (stdout):
       {
         "string-bs": {"type": "string", "value": "backspace\b"}
       }

     want:
       Exit code 1

FAIL invalid/control/string-del
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       string-del  = "null"

     output from parser-cmd (stdout):
       {
         "string-del": {"type": "string", "value": "null"}
       }

     want:
       Exit code 1

FAIL invalid/control/string-lf
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       string-lf   = "null"

     output from parser-cmd (stdout):
       {
         "string-lf": {"type": "string", "value": "null\u0010"}
       }

     want:
       Exit code 1

FAIL invalid/control/string-null
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       string-null = "null "

     output from parser-cmd (stdout):
       {
         "string-null": {"type": "string", "value": "null\u0000"}
       }

     want:
       Exit code 1

FAIL invalid/control/string-us
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       string-us   = "null"

     output from parser-cmd (stdout):
       {
         "string-us": {"type": "string", "value": "null\u001f"}
       }

     want:
       Exit code 1

FAIL invalid/inline-table/duplicate-key-3
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       tbl = { fruit = { apple.color = "red" }, fruit.apple.texture = { smooth = true } }

     output from parser-cmd (stdout):
       {
         "tbl": {
           "fruit": {
             "apple": {
               "color": {"type": "string", "value": "red"},
               "texture": {
                 "smooth": {"type": "bool", "value": "true"}
               }
             }
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/inline-table/overwrite-01
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       a.b=0
       # Since table "a" is already defined, it can't be replaced by an inline table.
       a={}

     output from parser-cmd (stdout):
       {
         "a": {
           "b": {"type": "integer", "value": "0"}
         }
       }

     want:
       Exit code 1

FAIL invalid/inline-table/overwrite-02
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       a={}
       # Inline tables are immutable and can't be extended
       [a.b]

     output from parser-cmd (stdout):
       {
         "a": {
           "b": {}
         }
       }

     want:
       Exit code 1

FAIL invalid/inline-table/overwrite-05
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       inline-t = { nest = {} }

       [inline-t.nest]

     output from parser-cmd (stdout):
       {
         "inline-t": {
           "nest": {}
         }
       }

     want:
       Exit code 1

FAIL invalid/inline-table/overwrite-08
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       tab = { inner = { dog = "best" }, inner.cat = "worst" }

     output from parser-cmd (stdout):
       {
         "tab": {
           "inner": {
             "cat": {"type": "string", "value": "worst"},
             "dog": {"type": "string", "value": "best"}
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/key/after-array
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [[agencies]] owner = "S Cjelli"

     output from parser-cmd (stdout):
       {
         "agencies": [{
           "owner": {"type": "string", "value": "S Cjelli"}
         }]
       }

     want:
       Exit code 1

FAIL invalid/key/after-table
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [error] this = "should not be here"

     output from parser-cmd (stdout):
       {
         "error": {
           "this": {"type": "string", "value": "should not be here"}
         }
       }

     want:
       Exit code 1

FAIL invalid/key/after-value
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       first = "Tom" last = "Preston-Werner" # INVALID

     output from parser-cmd (stdout):
       {
         "first": {"type": "string", "value": "Tom"},
         "last":  {"type": "string", "value": "Preston-Werner"}
       }

     want:
       Exit code 1

FAIL invalid/key/no-eol
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       a = 1 b = 2

     output from parser-cmd (stdout):
       {
         "a": {"type": "integer", "value": "1"},
         "b": {"type": "integer", "value": "2"}
       }

     want:
       Exit code 1

FAIL invalid/spec/inline-table-2-0
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [product]
       type = { name = "Nail" }
       type.edible = false  # INVALID

     output from parser-cmd (stdout):
       {
         "product": {
           "type": {
             "edible": {"type": "bool", "value": "false"},
             "name":   {"type": "string", "value": "Nail"}
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/spec/inline-table-3-0
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [product]
       type.name = "Nail"
       type = { edible = false }  # INVALID

     output from parser-cmd (stdout):
       {
         "product": {
           "type": {
             "edible": {"type": "bool", "value": "false"},
             "name":   {"type": "string", "value": "Nail"}
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/spec/table-9-0
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [fruit]
       apple.color = "red"
       apple.taste.sweet = true

       [fruit.apple]  # INVALID
       # [fruit.apple.taste]  # INVALID

       [fruit.apple.texture]  # you can add sub-tables
       smooth = true

     output from parser-cmd (stdout):
       {
         "fruit": {
           "apple": {
             "color": {"type": "string", "value": "red"},
             "taste": {
               "sweet": {"type": "bool", "value": "true"}
             },
             "texture": {
               "smooth": {"type": "bool", "value": "true"}
             }
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/spec/table-9-1
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [fruit]
       apple.color = "red"
       apple.taste.sweet = true

       # [fruit.apple]  # INVALID
       [fruit.apple.taste]  # INVALID

       [fruit.apple.texture]  # you can add sub-tables
       smooth = true

     output from parser-cmd (stdout):
       {
         "fruit": {
           "apple": {
             "color": {"type": "string", "value": "red"},
             "taste": {
               "sweet": {"type": "bool", "value": "true"}
             },
             "texture": {
               "smooth": {"type": "bool", "value": "true"}
             }
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/table/append-with-dotted-keys-1
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       # First a.b.c defines a table: a.b.c = {z=9}
       #
       # Then we define a.b.c.t = "str" to add a str to the above table, making it:
       #
       #   a.b.c = {z=9, t="..."}
       #
       # While this makes sense, logically, it was decided this is not valid TOML as
       # it's too confusing/convoluted.
       #
       # See: https://github.com/toml-lang/toml/issues/846
       #      https://github.com/toml-lang/toml/pull/859

       [a.b.c]
         z = 9

       [a]
         b.c.t = "Using dotted keys to add to [a.b.c] after explicitly defining it above is not allowed"

     output from parser-cmd (stdout):
       {
         "a": {
           "b": {
             "c": {
               "z": {"type": "integer", "value": "9"},
               "t": {
                 "type":  "string",
                 "value": "Using dotted keys to add to [a.b.c] after explicitly defining it above is not allowed"
               }
             }
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/table/append-with-dotted-keys-2
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       # This is the same issue as in injection-1.toml, except that nests one level
       # deeper. See that file for a more complete description.

       [a.b.c.d]
         z = 9

       [a]
         b.c.d.k.t = "Using dotted keys to add to [a.b.c.d] after explicitly defining it above is not allowed"

     output from parser-cmd (stdout):
       {
         "a": {
           "b": {
             "c": {
               "d": {
                 "z": {"type": "integer", "value": "9"},
                 "k": {
                   "t": {
                     "type":  "string",
                     "value": "Using dotted keys to add to [a.b.c.d] after explicitly defining it above is not allowed"
                   }
                 }
               }
             }
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/table/duplicate
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [a]
       b = 1

       [a]
       c = 2

     output from parser-cmd (stdout):
       {
         "a": {
           "b": {"type": "integer", "value": "1"},
           "c": {"type": "integer", "value": "2"}
         }
       }

     want:
       Exit code 1

FAIL invalid/table/duplicate-key-dotted-table
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [fruit]
       apple.color = "red"

       [fruit.apple] # INVALID

     output from parser-cmd (stdout):
       {
         "fruit": {
           "apple": {
             "color": {"type": "string", "value": "red"}
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/table/duplicate-key-dotted-table2
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [fruit]
       apple.taste.sweet = true

       [fruit.apple.taste] # INVALID

     output from parser-cmd (stdout):
       {
         "fruit": {
           "apple": {
             "taste": {
               "sweet": {"type": "bool", "value": "true"}
             }
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/table/redefine-2
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [t1]
       t2.t3.v = 0
       [t1.t2]

     output from parser-cmd (stdout):
       {
         "t1": {
           "t2": {
             "t3": {
               "v": {"type": "integer", "value": "0"}
             }
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/table/redefine-3
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [t1]
       t2.t3.v = 0
       [t1.t2.t3]

     output from parser-cmd (stdout):
       {
         "t1": {
           "t2": {
             "t3": {
               "v": {"type": "integer", "value": "0"}
             }
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/table/super-twice
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [a.b]
       [a]
       [a]

     output from parser-cmd (stdout):
       {
         "a": {
           "b": {}
         }
       }

     want:
       Exit code 1

toml-test v0001-01-01 [/Users/s23467/develop/tombi/target/debug/decode --toml-version v1.1.0-preview]: using embedded tests
  valid tests: 166 passed, 21 failed
invalid tests: 314 passed, 47 failed
