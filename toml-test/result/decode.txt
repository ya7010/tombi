FAIL valid/array/array
     Key "comments" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       ints = [1, 2, 3, ]
       floats = [1.1, 2.1, 3.1]
       strings = ["a", "b", "c"]
       dates = [
         1987-07-05T17:45:00Z,
         1979-05-27T07:32:00Z,
         2006-06-01T11:00:00Z,
       ]
       comments = [
                1,
                2, #this is ok
       ]

     output from parser-cmd (stdout):
       {
         "comments": [1, 2],
         "dates":    ["1987-07-05T17:45:00Z", "1979-05-27T07:32:00Z", "2006-06-01T11:00:00Z"],
         "floats":   [1, 2, 3],
         "ints":     [1, 2, 3],
         "strings":  ["a", "b", "c"]
       }

     want:
       {
           "comments": [
               {"type": "integer", "value": "1"},
               {"type": "integer", "value": "2"}
           ],
           "dates": [
               {"type": "datetime", "value": "1987-07-05T17:45:00Z"},
               {"type": "datetime", "value": "1979-05-27T07:32:00Z"},
               {"type": "datetime", "value": "2006-06-01T11:00:00Z"}
           ],
           "floats": [
               {"type": "float", "value": "1.1"},
               {"type": "float", "value": "2.1"},
               {"type": "float", "value": "3.1"}
           ],
           "ints": [
               {"type": "integer", "value": "1"},
               {"type": "integer", "value": "2"},
               {"type": "integer", "value": "3"}
           ],
           "strings": [
               {"type": "string", "value": "a"},
               {"type": "string", "value": "b"},
               {"type": "string", "value": "c"}
           ]
       }

FAIL valid/array/array-subtables
     Key "arr.subtab.val" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       [[arr]]
       [arr.subtab]
       val=1

       [[arr]]
       [arr.subtab]
       val=2

     output from parser-cmd (stdout):
       {
         "arr": [
           {
             "subtab": {"val": 1}
           },
           {
             "subtab": {"val": 2}
           }
         ]
       }

     want:
       {
           "arr": [
               {
                   "subtab": {
                       "val": {"type": "integer", "value": "1"}
                   }
               },
               {
                   "subtab": {
                       "val": {"type": "integer", "value": "2"}
                   }
               }
           ]
       }

FAIL valid/array/bool
     Key "a" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       a = [true, false]

     output from parser-cmd (stdout):
       {
         "a": [true, false]
       }

     want:
       {
           "a": [
               {"type": "bool", "value": "true"},
               {"type": "bool", "value": "false"}
           ]
       }

FAIL valid/array/hetergeneous
     Array lengths differ for key "mixed":
       Expected:     3
       Your encoder: 1

     input sent to parser-cmd:
       mixed = [[1, 2], ["a", "b"], [1.1, 2.1]]

     output from parser-cmd (stdout):
       {
         "mixed": [[2]]
       }

     want:
       {
           "mixed": [
               [
                   {"type": "integer", "value": "1"},
                   {"type": "integer", "value": "2"}
               ],
               [
                   {"type": "string", "value": "a"},
                   {"type": "string", "value": "b"}
               ],
               [
                   {"type": "float", "value": "1.1"},
                   {"type": "float", "value": "2.1"}
               ]
           ]
       }

FAIL valid/array/mixed-int-array
     Key "arrays-and-ints" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       arrays-and-ints =  [1, ["Arrays are not integers."]]

     output from parser-cmd (stdout):
       {
         "arrays-and-ints": [
           1,
           ["Arrays are not integers."]
         ]
       }

     want:
       {
           "arrays-and-ints": [
               {"type": "integer", "value": "1"},
               [{"type": "string", "value": "Arrays are not integers."}]
           ]
       }

FAIL valid/array/mixed-int-float
     Array lengths differ for key "ints-and-floats":
       Expected:     2
       Your encoder: 0

     input sent to parser-cmd:
       ints-and-floats = [1, 1.1]

     output from parser-cmd (stdout):
       {
         "ints-and-floats": []
       }

     want:
       {
           "ints-and-floats": [
               {"type": "integer", "value": "1"},
               {"type": "float", "value": "1.1"}
           ]
       }

FAIL valid/array/mixed-int-string
     Key "strings-and-ints" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       strings-and-ints = ["hi", 42]

     output from parser-cmd (stdout):
       {
         "strings-and-ints": ["hi", 42]
       }

     want:
       {
           "strings-and-ints": [
               {"type": "string", "value": "hi"},
               {"type": "integer", "value": "42"}
           ]
       }

FAIL valid/array/mixed-string-table
     Key "contributors" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       contributors = [
         "Foo Bar <foo@example.com>",
         { name = "Baz Qux", email = "bazqux@example.com", url = "https://example.com/bazqux" }
       ]

       # Start with a table as the first element. This tests a case that some libraries
       # might have where they will check if the first entry is a table/map/hash/assoc
       # array and then encode it as a table array. This was a reasonable thing to do
       # before TOML 1.0 since arrays could only contain one type, but now it's no
       # longer.
       mixed = [{k="a"}, "b", 1]

     output from parser-cmd (stdout):
       {
         "contributors": [
           "Foo Bar \u003cfoo@example.com\u003e",
           {"email": "bazqux@example.com", "name": "Baz Qux", "url": "https://example.com/bazqux"}
         ],
         "mixed": [
           {"k": "a"},
           "b",
           1
         ]
       }

     want:
       {
           "contributors": [
               {"type": "string", "value": "Foo Bar \u003cfoo@example.com\u003e"},
               {
                   "email": {"type": "string", "value": "bazqux@example.com"},
                   "name":  {"type": "string", "value": "Baz Qux"},
                   "url":   {"type": "string", "value": "https://example.com/bazqux"}
               }
           ],
           "mixed": [
               {
                   "k": {"type": "string", "value": "a"}
               },
               {"type": "string", "value": "b"},
               {"type": "integer", "value": "1"}
           ]
       }

FAIL valid/array/nested
     Key "nest" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       nest = [["a"], ["b"]]

     output from parser-cmd (stdout):
       {
         "nest": [
           ["a"],
           ["b"]
         ]
       }

     want:
       {
           "nest": [
               [{"type": "string", "value": "a"}],
               [{"type": "string", "value": "b"}]
           ]
       }

FAIL valid/array/nested-double
     Key "nest" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       nest = [
       	[
       		["a"],
       		[1, 2, [3]]
       	]
       ]

     output from parser-cmd (stdout):
       {
         "nest": [[
           ["a"],
           [
             1,
             2,
             [3]
           ]
         ]]
       }

     want:
       {
           "nest": [[
               [{"type": "string", "value": "a"}],
               [
                   {"type": "integer", "value": "1"},
                   {"type": "integer", "value": "2"},
                   [{"type": "integer", "value": "3"}]
               ]
           ]]
       }

FAIL valid/array/nospaces
     Key "ints" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       ints = [1,2,3]

     output from parser-cmd (stdout):
       {
         "ints": [1, 2, 3]
       }

     want:
       {
           "ints": [
               {"type": "integer", "value": "1"},
               {"type": "integer", "value": "2"},
               {"type": "integer", "value": "3"}
           ]
       }

FAIL valid/array/open-parent-table
     Key "parent-table.not-arr" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       [[parent-table.arr]]
       [[parent-table.arr]]
       [parent-table]
       not-arr = 1

     output from parser-cmd (stdout):
       {
         "parent-table": {"arr": [
           {},
           {}
         ], "not-arr": 1}
       }

     want:
       {
           "parent-table": {
               "not-arr": {"type": "integer", "value": "1"},
               "arr": [
                   {},
                   {}
               ]
           }
       }

FAIL valid/array/string-quote-comma
     Key "title" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       title = [
       "Client: \"XXXX\", Job: XXXX",
       "Code: XXXX"
       ]

     output from parser-cmd (stdout):
       {
         "title": ["Client: \"XXXX\", Job: XXXX", "Code: XXXX"]
       }

     want:
       {
           "title": [
               {"type": "string", "value": "Client: \"XXXX\", Job: XXXX"},
               {"type": "string", "value": "Code: XXXX"}
           ]
       }

FAIL valid/array/string-quote-comma-2
     Key "title" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       title = [ " \", ",]

     output from parser-cmd (stdout):
       {
         "title": [" \", "]
       }

     want:
       {
           "title": [{"type": "string", "value": " \", "}]
       }

FAIL valid/array/string-with-comma
     Key "title" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       title = [
       "Client: XXXX, Job: XXXX",
       "Code: XXXX"
       ]

     output from parser-cmd (stdout):
       {
         "title": ["Client: XXXX, Job: XXXX", "Code: XXXX"]
       }

     want:
       {
           "title": [
               {"type": "string", "value": "Client: XXXX, Job: XXXX"},
               {"type": "string", "value": "Code: XXXX"}
           ]
       }

FAIL valid/array/string-with-comma-2
     Key "title" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       title = [
       """Client: XXXX,
       Job: XXXX""",
       "Code: XXXX"
       ]

     output from parser-cmd (stdout):
       {
         "title": ["Client: XXXX,\nJob: XXXX", "Code: XXXX"]
       }

     want:
       {
           "title": [
               {"type": "string", "value": "Client: XXXX,\nJob: XXXX"},
               {"type": "string", "value": "Code: XXXX"}
           ]
       }

FAIL valid/array/strings
     Key "string_array" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       string_array = [ "all", 'strings', """are the same""", '''type''']

     output from parser-cmd (stdout):
       {
         "string_array": ["all", "strings", "are the same", "type"]
       }

     want:
       {
           "string_array": [
               {"type": "string", "value": "all"},
               {"type": "string", "value": "strings"},
               {"type": "string", "value": "are the same"},
               {"type": "string", "value": "type"}
           ]
       }

FAIL valid/array/table-array-string-backslash
     Key "foo.bar" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       foo = [ { bar="\"{{baz}}\""} ]

     output from parser-cmd (stdout):
       {
         "foo": [{"bar": "\"{{baz}}\""}]
       }

     want:
       {
           "foo": [{
               "bar": {"type": "string", "value": "\"{{baz}}\""}
           }]
       }

FAIL valid/array/trailing-comma
     Key "arr-1" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       arr-1 = [1,]

       arr-2 = [2,3,]

       arr-3 = [4,
       ]

       arr-4 = [
       	5,
       	6,
       ]

     output from parser-cmd (stdout):
       {
         "arr-1": [1],
         "arr-2": [2, 3],
         "arr-3": [4],
         "arr-4": [5, 6]
       }

     want:
       {
           "arr-1": [{"type": "integer", "value": "1"}],
           "arr-3": [{"type": "integer", "value": "4"}],
           "arr-2": [
               {"type": "integer", "value": "2"},
               {"type": "integer", "value": "3"}
           ],
           "arr-4": [
               {"type": "integer", "value": "5"},
               {"type": "integer", "value": "6"}
           ]
       }

FAIL valid/bool/bool
     Key "f" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       t = true
       f = false

     output from parser-cmd (stdout):
       {
         "f": false,
         "t": true
       }

     want:
       {
           "f": {"type": "bool", "value": "false"},
           "t": {"type": "bool", "value": "true"}
       }

FAIL valid/comment/after-literal-no-ws
     Could not find key "inf" in parser output.

     input sent to parser-cmd:
       inf=inf#infinity
       nan=nan#not a number
       true=true#true
       false=false#false

     output from parser-cmd (stdout):
       {
         "false": false,
         "true":  true
       }

     want:
       {
           "false": {"type": "bool", "value": "false"},
           "inf":   {"type": "float", "value": "inf"},
           "nan":   {"type": "float", "value": "nan"},
           "true":  {"type": "bool", "value": "true"}
       }

FAIL valid/comment/at-eof
     Key "key" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       # This is a full-line comment
       key = "value" # This is a comment at the end of a line

     output from parser-cmd (stdout):
       {
         "key": "value"
       }

     want:
       {
           "key": {"type": "string", "value": "value"}
       }

FAIL valid/comment/at-eof2
     Key "key" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       # This is a full-line comment
       key = "value" # This is a comment at the end of a line

     output from parser-cmd (stdout):
       {
         "key": "value"
       }

     want:
       {
           "key": {"type": "string", "value": "value"}
       }

FAIL valid/comment/everywhere
     Key "group.answer" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       # Top comment.
         # Top comment.
       # Top comment.

       # [no-extraneous-groups-please]

       [group] # Comment
       answer = 42 # Comment
       # no-extraneous-keys-please = 999
       # Inbetween comment.
       more = [ # Comment
         # What about multiple # comments?
         # Can you handle it?
         #
                 # Evil.
       # Evil.
         42, 42, # Comments within arrays are fun.
         # What about multiple # comments?
         # Can you handle it?
         #
                 # Evil.
       # Evil.
       # ] Did I fool you?
       ] # Hopefully not.

       # Make sure the space between the datetime and "#" isn't lexed.
       dt = 1979-05-27T07:32:12-07:00  # c
       d = 1979-05-27 # Comment

     output from parser-cmd (stdout):
       {
         "group": {"answer": 42, "d": "1979-05-27", "dt": "1979-05-27T07:32:12-07:00", "more": [42, 42]}
       }

     want:
       {
           "group": {
               "answer": {"type": "integer", "value": "42"},
               "d":      {"type": "date-local", "value": "1979-05-27"},
               "dt":     {"type": "datetime", "value": "1979-05-27T07:32:12-07:00"},
               "more": [
                   {"type": "integer", "value": "42"},
                   {"type": "integer", "value": "42"}
               ]
           }
       }

FAIL valid/comment/tricky
     Key "hash#tag.#!" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       [section]#attached comment
       #[notsection]
       one = "11"#cmt
       two = "22#"
       three = '#'

       four = """# no comment
       # nor this
       #also not comment"""#is_comment

       five = 5.5#66
       six = 6#7
       8 = "eight"
       #nine = 99
       ten = 10e2#1
       eleven = 1.11e1#23

       ["hash#tag"]
       "#!" = "hash bang"
       arr3 = [ "#", '#', """###""" ]
       arr4 = [ 1,# 9, 9,
       2#,9
       ,#9
       3#]
       ,4]
       arr5 = [[[[#["#"],
       ["#"]]]]#]
       ]
       tbl1 = { "#" = '}#'}#}}

     output from parser-cmd (stdout):
       {
         "hash#tag": {
           "#!":   "hash bang",
           "arr3": ["#", "#", "###"],
           "arr4": [1, 2, 3, 4],
           "arr5": [[[[["#"]]]]],
           "tbl1": {"#": "}#"}
         },
         "section": {
           "8":      "eight",
           "eleven": 11,
           "five":   6,
           "four":   "# no comment\n# nor this\n#also not comment",
           "one":    "11",
           "six":    6,
           "ten":    1000,
           "three":  "#",
           "two":    "22#"
         }
       }

     want:
       {
           "hash#tag": {
               "#!":   {"type": "string", "value": "hash bang"},
               "arr5": [[[[[{"type": "string", "value": "#"}]]]]],
               "arr3": [
                   {"type": "string", "value": "#"},
                   {"type": "string", "value": "#"},
                   {"type": "string", "value": "###"}
               ],
               "arr4": [
                   {"type": "integer", "value": "1"},
                   {"type": "integer", "value": "2"},
                   {"type": "integer", "value": "3"},
                   {"type": "integer", "value": "4"}
               ],
               "tbl1": {
                   "#": {"type": "string", "value": "}#"}
               }
           },
           "section": {
               "8":      {"type": "string", "value": "eight"},
               "eleven": {"type": "float", "value": "11.1"},
               "five":   {"type": "float", "value": "5.5"},
               "four":   {"type": "string", "value": "# no comment\n# nor this\n#also not comment"},
               "one":    {"type": "string", "value": "11"},
               "six":    {"type": "integer", "value": "6"},
               "ten":    {"type": "float", "value": "1000.0"},
               "three":  {"type": "string", "value": "#"},
               "two":    {"type": "string", "value": "22#"}
           }
       }

FAIL valid/datetime/datetime
     Key "lower" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       space = 1987-07-05 17:45:00Z

       # ABNF is case-insensitive, both "Z" and "z" must be supported.
       lower = 1987-07-05t17:45:00z

     output from parser-cmd (stdout):
       {
         "lower": "1987-07-05T17:45:00Z",
         "space": "1987-07-05T17:45:00Z"
       }

     want:
       {
           "lower": {"type": "datetime", "value": "1987-07-05T17:45:00Z"},
           "space": {"type": "datetime", "value": "1987-07-05T17:45:00Z"}
       }

FAIL valid/datetime/edge
     Key "first-date" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       first-offset = 0001-01-01 00:00:00Z
       first-local  = 0001-01-01 00:00:00
       first-date   = 0001-01-01

       last-offset = 9999-12-31 23:59:59Z
       last-local  = 9999-12-31 23:59:59
       last-date   = 9999-12-31

     output from parser-cmd (stdout):
       {
         "first-date":   "0001-01-01",
         "first-local":  "0001-01-01T00:00:00",
         "first-offset": "0001-01-01T00:00:00Z",
         "last-date":    "9999-12-31",
         "last-local":   "9999-12-31T23:59:59",
         "last-offset":  "9999-12-31T23:59:59Z"
       }

     want:
       {
           "first-date":   {"type": "date-local", "value": "0001-01-01"},
           "first-local":  {"type": "datetime-local", "value": "0001-01-01T00:00:00"},
           "first-offset": {"type": "datetime", "value": "0001-01-01T00:00:00Z"},
           "last-date":    {"type": "date-local", "value": "9999-12-31"},
           "last-local":   {"type": "datetime-local", "value": "9999-12-31T23:59:59"},
           "last-offset":  {"type": "datetime", "value": "9999-12-31T23:59:59Z"}
       }

FAIL valid/datetime/leap-year
     invalid number
     invalid number
     invalid number
     invalid number
     invalid number
     invalid number
     unknown line
     unknown line
     unknown line
     unknown line
     unknown line
     unknown line
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       2000-datetime       = 2000-02-29 15:15:15Z
       2000-datetime-local = 2000-02-29 15:15:15
       2000-date           = 2000-02-29

       2024-datetime       = 2024-02-29 15:15:15Z
       2024-datetime-local = 2024-02-29 15:15:15
       2024-date           = 2024-02-29

     output from parser-cmd (stderr):
       invalid number
       invalid number
       invalid number
       invalid number
       invalid number
       invalid number
       unknown line
       unknown line
       unknown line
       unknown line
       unknown line
       unknown line
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/datetime/local
     Key "local" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       local = 1987-07-05T17:45:00
       milli = 1977-12-21T10:32:00.555
       space = 1987-07-05 17:45:00

     output from parser-cmd (stdout):
       {
         "local": "1987-07-05T17:45:00",
         "milli": "1977-12-21T10:32:00.555",
         "space": "1987-07-05T17:45:00"
       }

     want:
       {
           "local": {"type": "datetime-local", "value": "1987-07-05T17:45:00"},
           "milli": {"type": "datetime-local", "value": "1977-12-21T10:32:00.555"},
           "space": {"type": "datetime-local", "value": "1987-07-05T17:45:00"}
       }

FAIL valid/datetime/local-date
     Key "bestdayever" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       bestdayever = 1987-07-05

     output from parser-cmd (stdout):
       {
         "bestdayever": "1987-07-05"
       }

     want:
       {
           "bestdayever": {"type": "date-local", "value": "1987-07-05"}
       }

FAIL valid/datetime/local-time
     Key "besttimeever" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       besttimeever = 17:45:00
       milliseconds = 10:32:00.555

     output from parser-cmd (stdout):
       {
         "besttimeever": "17:45:00",
         "milliseconds": "10:32:00.555"
       }

     want:
       {
           "besttimeever": {"type": "time-local", "value": "17:45:00"},
           "milliseconds": {"type": "time-local", "value": "10:32:00.555"}
       }

FAIL valid/datetime/milliseconds
     Key "utc1" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       utc1  = 1987-07-05T17:45:56.123Z
       utc2  = 1987-07-05T17:45:56.6Z
       wita1 = 1987-07-05T17:45:56.123+08:00
       wita2 = 1987-07-05T17:45:56.6+08:00

     output from parser-cmd (stdout):
       {
         "utc1":  "1987-07-05T17:45:56.123Z",
         "utc2":  "1987-07-05T17:45:56.600Z",
         "wita1": "1987-07-05T17:45:56.123+08:00",
         "wita2": "1987-07-05T17:45:56.600+08:00"
       }

     want:
       {
           "utc1":  {"type": "datetime", "value": "1987-07-05T17:45:56.123Z"},
           "utc2":  {"type": "datetime", "value": "1987-07-05T17:45:56.600Z"},
           "wita1": {"type": "datetime", "value": "1987-07-05T17:45:56.123+08:00"},
           "wita2": {"type": "datetime", "value": "1987-07-05T17:45:56.600+08:00"}
       }

FAIL valid/datetime/timezone
     Key "nzdt" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       utc  = 1987-07-05T17:45:56Z
       pdt  = 1987-07-05T17:45:56-05:00
       nzst = 1987-07-05T17:45:56+12:00
       nzdt = 1987-07-05T17:45:56+13:00  # DST

     output from parser-cmd (stdout):
       {
         "nzdt": "1987-07-05T17:45:56+13:00",
         "nzst": "1987-07-05T17:45:56+12:00",
         "pdt":  "1987-07-05T17:45:56-05:00",
         "utc":  "1987-07-05T17:45:56Z"
       }

     want:
       {
           "nzdt": {"type": "datetime", "value": "1987-07-05T17:45:56+13:00"},
           "nzst": {"type": "datetime", "value": "1987-07-05T17:45:56+12:00"},
           "pdt":  {"type": "datetime", "value": "1987-07-05T17:45:56-05:00"},
           "utc":  {"type": "datetime", "value": "1987-07-05T17:45:56Z"}
       }

FAIL valid/example
     Key "best-day-ever" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       best-day-ever = 1987-07-05T17:45:00Z

       [numtheory]
       boring = false
       perfection = [6, 28, 496]

     output from parser-cmd (stdout):
       {
         "best-day-ever": "1987-07-05T17:45:00Z",
         "numtheory":     {"boring": false, "perfection": [6, 28, 496]}
       }

     want:
       {
           "best-day-ever": {"type": "datetime", "value": "1987-07-05T17:45:00Z"},
           "numtheory": {
               "boring": {"type": "bool", "value": "false"},
               "perfection": [
                   {"type": "integer", "value": "6"},
                   {"type": "integer", "value": "28"},
                   {"type": "integer", "value": "496"}
               ]
           }
       }

FAIL valid/float/exponent
     Key "lower" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       lower = 3e2
       upper = 3E2
       neg = 3e-2
       pos = 3E+2
       zero = 3e0
       pointlower = 3.1e2
       pointupper = 3.1E2
       minustenth = -1E-1

     output from parser-cmd (stdout):
       {
         "lower":      300,
         "minustenth": -0,
         "neg":        0,
         "pointlower": 310,
         "pointupper": 310,
         "pos":        300,
         "upper":      300,
         "zero":       3
       }

     want:
       {
           "lower":      {"type": "float", "value": "300.0"},
           "minustenth": {"type": "float", "value": "-0.1"},
           "neg":        {"type": "float", "value": "0.03"},
           "pointlower": {"type": "float", "value": "310.0"},
           "pointupper": {"type": "float", "value": "310.0"},
           "pos":        {"type": "float", "value": "300.0"},
           "upper":      {"type": "float", "value": "300.0"},
           "zero":       {"type": "float", "value": "3.0"}
       }

FAIL valid/float/float
     Key "negpi" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       pi = 3.14
       pospi = +3.14
       negpi = -3.14
       zero-intpart = 0.123

     output from parser-cmd (stdout):
       {
         "negpi":        -3,
         "pi":           3,
         "pospi":        3,
         "zero-intpart": 0
       }

     want:
       {
           "negpi":        {"type": "float", "value": "-3.14"},
           "pi":           {"type": "float", "value": "3.14"},
           "pospi":        {"type": "float", "value": "3.14"},
           "zero-intpart": {"type": "float", "value": "0.123"}
       }

FAIL valid/float/inf-and-nan
     Could not find key "nan" in parser output.

     input sent to parser-cmd:
       # We don't encode +nan and -nan back with the signs; many languages don't
       # support a sign on NaN (it doesn't really make much sense).
       nan = nan
       nan_neg = -nan
       nan_plus = +nan
       infinity = inf
       infinity_neg = -inf
       infinity_plus = +inf

     output from parser-cmd (stdout):
       {
         "infinity":      null,
         "infinity_neg":  null,
         "infinity_plus": null,
         "nan_neg":       null,
         "nan_plus":      null
       }

     want:
       {
           "infinity":      {"type": "float", "value": "inf"},
           "infinity_neg":  {"type": "float", "value": "-inf"},
           "infinity_plus": {"type": "float", "value": "inf"},
           "nan":           {"type": "float", "value": "nan"},
           "nan_neg":       {"type": "float", "value": "nan"},
           "nan_plus":      {"type": "float", "value": "nan"}
       }

FAIL valid/float/long
     Key "longpi" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       longpi = 3.141592653589793
       neglongpi = -3.141592653589793

     output from parser-cmd (stdout):
       {
         "longpi":    3,
         "neglongpi": -3
       }

     want:
       {
           "longpi":    {"type": "float", "value": "3.141592653589793"},
           "neglongpi": {"type": "float", "value": "-3.141592653589793"}
       }

FAIL valid/float/max-int
     invalid float: invalid float literal
     invalid float: invalid float literal
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       # Maximum and minimum safe natural numbers.
       max_float =  9_007_199_254_740_991.0
       min_float = -9_007_199_254_740_991.0

     output from parser-cmd (stderr):
       invalid float: invalid float literal
       invalid float: invalid float literal
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/float/underscore
     invalid float: invalid float literal
     invalid float: invalid float literal
     invalid float: invalid float literal
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       before = 3_141.5927
       after = 3141.592_7
       exponent = 3e1_4

     output from parser-cmd (stderr):
       invalid float: invalid float literal
       invalid float: invalid float literal
       invalid float: invalid float literal
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/float/zero
     Key "exponent" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       zero = 0.0
       signed-pos = +0.0
       signed-neg = -0.0
       exponent = 0e0
       exponent-two-0 = 0e00
       exponent-signed-pos = +0e0
       exponent-signed-neg = -0e0

     output from parser-cmd (stdout):
       {
         "exponent":            0,
         "exponent-signed-neg": -0,
         "exponent-signed-pos": 0,
         "exponent-two-0":      0,
         "signed-neg":          -0,
         "signed-pos":          0,
         "zero":                0
       }

     want:
       {
           "exponent":            {"type": "float", "value": "0"},
           "exponent-signed-neg": {"type": "float", "value": "-0"},
           "exponent-signed-pos": {"type": "float", "value": "0"},
           "exponent-two-0":      {"type": "float", "value": "0"},
           "signed-neg":          {"type": "float", "value": "-0"},
           "signed-pos":          {"type": "float", "value": "0"},
           "zero":                {"type": "float", "value": "0"}
       }

FAIL valid/implicit-and-explicit-after
     Key "a.b.c.answer" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       [a.b.c]
       answer = 42

       [a]
       better = 43

     output from parser-cmd (stdout):
       {
         "a": {
           "better": 43,
           "b": {
             "c": {"answer": 42}
           }
         }
       }

     want:
       {
           "a": {
               "better": {"type": "integer", "value": "43"},
               "b": {
                   "c": {
                       "answer": {"type": "integer", "value": "42"}
                   }
               }
           }
       }

FAIL valid/implicit-and-explicit-before
     Key "a.b.c.answer" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       [a]
       better = 43

       [a.b.c]
       answer = 42

     output from parser-cmd (stdout):
       {
         "a": {
           "better": 43,
           "b": {
             "c": {"answer": 42}
           }
         }
       }

     want:
       {
           "a": {
               "better": {"type": "integer", "value": "43"},
               "b": {
                   "c": {
                       "answer": {"type": "integer", "value": "42"}
                   }
               }
           }
       }

FAIL valid/implicit-groups
     Key "a.b.c.answer" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       [a.b.c]
       answer = 42

     output from parser-cmd (stdout):
       {
         "a": {
           "b": {
             "c": {"answer": 42}
           }
         }
       }

     want:
       {
           "a": {
               "b": {
                   "c": {
                       "answer": {"type": "integer", "value": "42"}
                   }
               }
           }
       }

FAIL valid/inline-table/array
     Key "arr.a" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       arr = [ {'a'= 1}, {'a'= 2} ]

       people = [{first_name = "Bruce", last_name = "Springsteen"},
                 {first_name = "Eric", last_name = "Clapton"},
                 {first_name = "Bob", last_name = "Seger"}]

     output from parser-cmd (stdout):
       {
         "arr": [
           {"a": 1},
           {"a": 2}
         ],
         "people": [
           {"first_name": "Bruce", "last_name": "Springsteen"},
           {"first_name": "Eric", "last_name": "Clapton"},
           {"first_name": "Bob", "last_name": "Seger"}
         ]
       }

     want:
       {
           "arr": [
               {
                   "a": {"type": "integer", "value": "1"}
               },
               {
                   "a": {"type": "integer", "value": "2"}
               }
           ],
           "people": [
               {
                   "first_name": {"type": "string", "value": "Bruce"},
                   "last_name":  {"type": "string", "value": "Springsteen"}
               },
               {
                   "first_name": {"type": "string", "value": "Eric"},
                   "last_name":  {"type": "string", "value": "Clapton"}
               },
               {
                   "first_name": {"type": "string", "value": "Bob"},
                   "last_name":  {"type": "string", "value": "Seger"}
               }
           ]
       }

FAIL valid/inline-table/array-values
     inline table must be single line
     inline table must be single line
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       # "No newlines are allowed between the curly braces unless they are valid within
       # a value"

       a = { a = [
       ]}

       b = { a = [
       		1,
       		2,
       	], b = [
       		3,
       		4,
       	]}

     output from parser-cmd (stderr):
       inline table must be single line
       inline table must be single line
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/inline-table/bool
     Key "a.a" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       a = {a = true, b = false}

     output from parser-cmd (stdout):
       {
         "a": {"a": true, "b": false}
       }

     want:
       {
           "a": {
               "a": {"type": "bool", "value": "true"},
               "b": {"type": "bool", "value": "false"}
           }
       }

FAIL valid/inline-table/empty
     Key "empty_in_array.not_empty" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       empty1 = {}
       empty2 = { }
       empty_in_array = [ { not_empty = 1 }, {} ]
       empty_in_array2 = [{},{not_empty=1}]
       many_empty = [{},{},{}]
       nested_empty = {"empty"={}}
       with_cmt ={            }#nothing here

     output from parser-cmd (stdout):
       {
         "empty1":   {},
         "empty2":   {},
         "with_cmt": {},
         "empty_in_array": [
           {"not_empty": 1},
           {}
         ],
         "empty_in_array2": [
           {},
           {"not_empty": 1}
         ],
         "many_empty": [
           {},
           {},
           {}
         ],
         "nested_empty": {
           "empty": {}
         }
       }

     want:
       {
           "empty1":   {},
           "empty2":   {},
           "with_cmt": {},
           "empty_in_array": [
               {
                   "not_empty": {"type": "integer", "value": "1"}
               },
               {}
           ],
           "empty_in_array2": [
               {},
               {
                   "not_empty": {"type": "integer", "value": "1"}
               }
           ],
           "many_empty": [
               {},
               {},
               {}
           ],
           "nested_empty": {
               "empty": {}
           }
       }

FAIL valid/inline-table/end-in-bool
     Key "black.allow_prereleases" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       black = { python=">3.6", version=">=18.9b0", allow_prereleases=true }

     output from parser-cmd (stdout):
       {
         "black": {"allow_prereleases": true, "python": "\u003e3.6", "version": "\u003e=18.9b0"}
       }

     want:
       {
           "black": {
               "allow_prereleases": {"type": "bool", "value": "true"},
               "python":            {"type": "string", "value": "\u003e3.6"},
               "version":           {"type": "string", "value": "\u003e=18.9b0"}
           }
       }

FAIL valid/inline-table/inline-table
     Key "name.first" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       name        = { first = "Tom", last = "Preston-Werner" }
       point       = { x = 1, y = 2 }
       simple      = { a = 1 }
       str-key     = { "a" = 1 }
       table-array = [{ "a" = 1 }, { "b" = 2 }]

     output from parser-cmd (stdout):
       {
         "name":    {"first": "Tom", "last": "Preston-Werner"},
         "point":   {"x": 1, "y": 2},
         "simple":  {"a": 1},
         "str-key": {"a": 1},
         "table-array": [
           {"a": 1},
           {"b": 2}
         ]
       }

     want:
       {
           "name": {
               "first": {"type": "string", "value": "Tom"},
               "last":  {"type": "string", "value": "Preston-Werner"}
           },
           "point": {
               "x": {"type": "integer", "value": "1"},
               "y": {"type": "integer", "value": "2"}
           },
           "simple": {
               "a": {"type": "integer", "value": "1"}
           },
           "str-key": {
               "a": {"type": "integer", "value": "1"}
           },
           "table-array": [
               {
                   "a": {"type": "integer", "value": "1"}
               },
               {
                   "b": {"type": "integer", "value": "2"}
               }
           ]
       }

FAIL valid/inline-table/key-dotted-1
     Key "a.a.b" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       a = {   a.b  =  1   }
       b = {   "a"."b"  =  1   }
       c = {   a   .   b  =  1   }
       d = {   'a'   .   "b"  =  1   }
       e = {a.b=1}

     output from parser-cmd (stdout):
       {
         "a": {
           "a": {"b": 1}
         },
         "b": {
           "a": {"b": 1}
         },
         "c": {
           "a": {"b": 1}
         },
         "d": {
           "a": {"b": 1}
         },
         "e": {
           "a": {"b": 1}
         }
       }

     want:
       {
           "a": {
               "a": {
                   "b": {"type": "integer", "value": "1"}
               }
           },
           "b": {
               "a": {
                   "b": {"type": "integer", "value": "1"}
               }
           },
           "c": {
               "a": {
                   "b": {"type": "integer", "value": "1"}
               }
           },
           "d": {
               "a": {
                   "b": {"type": "integer", "value": "1"}
               }
           },
           "e": {
               "a": {
                   "b": {"type": "integer", "value": "1"}
               }
           }
       }

FAIL valid/inline-table/key-dotted-2
     Key "many.dots.here.dot.dot.dot.a.b.c" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       many.dots.here.dot.dot.dot = {a.b.c = 1, a.b.d = 2}

     output from parser-cmd (stdout):
       {
         "many": {
           "dots": {
             "here": {
               "dot": {
                 "dot": {
                   "dot": {
                     "a": {
                       "b": {"c": 1, "d": 2}
                     }
                   }
                 }
               }
             }
           }
         }
       }

     want:
       {
           "many": {
               "dots": {
                   "here": {
                       "dot": {
                           "dot": {
                               "dot": {
                                   "a": {
                                       "b": {
                                           "c": {"type": "integer", "value": "1"},
                                           "d": {"type": "integer", "value": "2"}
                                       }
                                   }
                               }
                           }
                       }
                   }
               }
           }
       }

FAIL valid/inline-table/key-dotted-3
     Key "tbl.a.b.c.d.e" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       [tbl]
       a.b.c = {d.e=1}

       [tbl.x]
       a.b.c = {d.e=1}

     output from parser-cmd (stdout):
       {
         "tbl": {
           "a": {
             "b": {
               "c": {
                 "d": {"e": 1}
               }
             }
           },
           "x": {
             "a": {
               "b": {
                 "c": {
                   "d": {"e": 1}
                 }
               }
             }
           }
         }
       }

     want:
       {
           "tbl": {
               "a": {
                   "b": {
                       "c": {
                           "d": {
                               "e": {"type": "integer", "value": "1"}
                           }
                       }
                   }
               },
               "x": {
                   "a": {
                       "b": {
                           "c": {
                               "d": {
                                   "e": {"type": "integer", "value": "1"}
                               }
                           }
                       }
                   }
               }
           }
       }

FAIL valid/inline-table/key-dotted-4
     Key "arr.T.a.b" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       [[arr]]
       t = {a.b=1}
       T = {a.b=1}

       [[arr]]
       t = {a.b=2}
       T = {a.b=2}

     output from parser-cmd (stdout):
       {
         "arr": [
           {
             "T": {
               "a": {"b": 1}
             },
             "t": {
               "a": {"b": 1}
             }
           },
           {
             "T": {
               "a": {"b": 2}
             },
             "t": {
               "a": {"b": 2}
             }
           }
         ]
       }

     want:
       {
           "arr": [
               {
                   "T": {
                       "a": {
                           "b": {"type": "integer", "value": "1"}
                       }
                   },
                   "t": {
                       "a": {
                           "b": {"type": "integer", "value": "1"}
                       }
                   }
               },
               {
                   "T": {
                       "a": {
                           "b": {"type": "integer", "value": "2"}
                       }
                   },
                   "t": {
                       "a": {
                           "b": {"type": "integer", "value": "2"}
                       }
                   }
               }
           ]
       }

FAIL valid/inline-table/key-dotted-5
     Key "arr-1.a.b" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       arr-1 = [{a.b = 1}]
       arr-2 = ["str", {a.b = 1}]

       arr-3 = [{a.b = 1}, {a.b = 2}]
       arr-4 = ["str", {a.b = 1}, {a.b = 2}]

     output from parser-cmd (stdout):
       {
         "arr-1": [{
           "a": {"b": 1}
         }],
         "arr-2": [
           "str",
           {
             "a": {"b": 1}
           }
         ],
         "arr-3": [
           {
             "a": {"b": 1}
           },
           {
             "a": {"b": 2}
           }
         ],
         "arr-4": [
           "str",
           {
             "a": {"b": 1}
           },
           {
             "a": {"b": 2}
           }
         ]
       }

     want:
       {
           "arr-1": [{
               "a": {
                   "b": {"type": "integer", "value": "1"}
               }
           }],
           "arr-2": [
               {"type": "string", "value": "str"},
               {
                   "a": {
                       "b": {"type": "integer", "value": "1"}
                   }
               }
           ],
           "arr-3": [
               {
                   "a": {
                       "b": {"type": "integer", "value": "1"}
                   }
               },
               {
                   "a": {
                       "b": {"type": "integer", "value": "2"}
                   }
               }
           ],
           "arr-4": [
               {"type": "string", "value": "str"},
               {
                   "a": {
                       "b": {"type": "integer", "value": "1"}
                   }
               },
               {
                   "a": {
                       "b": {"type": "integer", "value": "2"}
                   }
               }
           ]
       }

FAIL valid/inline-table/key-dotted-6
     Key "top.dot.dot.dot.dot.dot" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       top.dot.dot = [
       	{dot.dot.dot = 1},
       	{dot.dot.dot = 2},
       ]

     output from parser-cmd (stdout):
       {
         "top": {
           "dot": {
             "dot": [
               {
                 "dot": {
                   "dot": {"dot": 1}
                 }
               },
               {
                 "dot": {
                   "dot": {"dot": 2}
                 }
               }
             ]
           }
         }
       }

     want:
       {
           "top": {
               "dot": {
                   "dot": [
                       {
                           "dot": {
                               "dot": {
                                   "dot": {"type": "integer", "value": "1"}
                               }
                           }
                       },
                       {
                           "dot": {
                               "dot": {
                                   "dot": {"type": "integer", "value": "2"}
                               }
                           }
                       }
                   ]
               }
           }
       }

FAIL valid/inline-table/key-dotted-7
     Key "arr.a.b.c.d" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       arr = [
       	{a.b = [{c.d = 1}]}
       ]

     output from parser-cmd (stdout):
       {
         "arr": [{
           "a": {"b": [{
             "c": {"d": 1}
           }]}
         }]
       }

     want:
       {
           "arr": [{
               "a": {"b": [{
                   "c": {
                       "d": {"type": "integer", "value": "1"}
                   }
               }]}
           }]
       }

FAIL valid/inline-table/multiline
     inline table must be single line
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       tbl_multiline = { a = 1, b = """
       multiline
       """, c = """and yet
       another line""", d = 4 }

     output from parser-cmd (stderr):
       inline table must be single line
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/inline-table/nest
     Key "arr_arr_tbl_val.one" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       tbl_tbl_empty = { tbl_0 = {} }
       tbl_tbl_val   = { tbl_1 = { one = 1 } }
       tbl_arr_tbl   = { arr_tbl = [ { one = 1 } ] }
       arr_tbl_tbl   = [ { tbl = { one = 1 } } ]

       # Array-of-array-of-table is interesting because it can only
       # be represented in inline form.
       arr_arr_tbl_empty = [ [ {} ] ]
       arr_arr_tbl_val = [ [ { one = 1 } ] ]
       arr_arr_tbls  = [ [ { one = 1 }, { two = 2 } ] ]

     output from parser-cmd (stdout):
       {
         "arr_arr_tbl_empty": [[{}]],
         "arr_arr_tbl_val":   [[{"one": 1}]],
         "arr_arr_tbls":      [[
           {"one": 1},
           {"two": 2}
         ]],
         "arr_tbl_tbl":       [{
           "tbl": {"one": 1}
         }],
         "tbl_arr_tbl":       {"arr_tbl": [{"one": 1}]},
         "tbl_tbl_empty": {
           "tbl_0": {}
         },
         "tbl_tbl_val": {
           "tbl_1": {"one": 1}
         }
       }

     want:
       {
           "arr_arr_tbl_empty": [[{}]],
           "arr_arr_tbl_val":   [[{
               "one": {"type": "integer", "value": "1"}
           }]],
           "arr_arr_tbls":      [[
               {
                   "one": {"type": "integer", "value": "1"}
               },
               {
                   "two": {"type": "integer", "value": "2"}
               }
           ]],
           "arr_tbl_tbl":       [{
               "tbl": {
                   "one": {"type": "integer", "value": "1"}
               }
           }],
           "tbl_arr_tbl":       {"arr_tbl": [{
               "one": {"type": "integer", "value": "1"}
           }]},
           "tbl_tbl_empty": {
               "tbl_0": {}
           },
           "tbl_tbl_val": {
               "tbl_1": {
                   "one": {"type": "integer", "value": "1"}
               }
           }
       }

FAIL valid/inline-table/spaces
     Key "clap-1.features" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       # https://github.com/toml-lang/toml-test/issues/146
       clap-1 = { version = "4"  , features = ["derive", "cargo"] }

       # Contains some literal tabs!
       clap-2 = { version = "4"	   	,	  	features = [   "derive" 	  ,  	  "cargo"   ]   , nest   =   {  	  "a"   =   'x'  , 	  'b'   = [ 1.5    ,   9.0  ]  }  }

     output from parser-cmd (stdout):
       {
         "clap-1": {"features": ["derive", "cargo"], "version": "4"},
         "clap-2": {
           "features": ["derive", "cargo"],
           "nest":     {"a": "x", "b": [2, 9]},
           "version":  "4"
         }
       }

     want:
       {
           "clap-1": {
               "version": {"type": "string", "value": "4"},
               "features": [
                   {"type": "string", "value": "derive"},
                   {"type": "string", "value": "cargo"}
               ]
           },
           "clap-2": {
               "version": {"type": "string", "value": "4"},
               "features": [
                   {"type": "string", "value": "derive"},
                   {"type": "string", "value": "cargo"}
               ],
               "nest": {
                   "a": {"type": "string", "value": "x"},
                   "b": [
                       {"type": "float", "value": "1.5"},
                       {"type": "float", "value": "9"}
                   ]
               }
           }
       }

FAIL valid/integer/float64-max
     invalid integer: invalid digit found in string
     invalid integer: invalid digit found in string
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       # Maximum and minimum safe float64 natural numbers. Mainly here for
       # -int-as-float.
       max_int =  9_007_199_254_740_991
       min_int = -9_007_199_254_740_991

     output from parser-cmd (stderr):
       invalid integer: invalid digit found in string
       invalid integer: invalid digit found in string
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/integer/integer
     Key "answer" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       answer = 42
       posanswer = +42
       neganswer = -42
       zero = 0

     output from parser-cmd (stdout):
       {
         "answer":    42,
         "neganswer": -42,
         "posanswer": 42,
         "zero":      0
       }

     want:
       {
           "answer":    {"type": "integer", "value": "42"},
           "neganswer": {"type": "integer", "value": "-42"},
           "posanswer": {"type": "integer", "value": "42"},
           "zero":      {"type": "integer", "value": "0"}
       }

FAIL valid/integer/literals
     invalid integer: invalid digit found in string
     invalid integer: invalid digit found in string
     invalid integer: invalid digit found in string
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       bin1 = 0b11010110
       bin2 = 0b1_0_1

       oct1 = 0o01234567
       oct2 = 0o755
       oct3 = 0o7_6_5

       hex1 = 0xDEADBEEF
       hex2 = 0xdeadbeef
       hex3 = 0xdead_beef
       hex4 = 0x00987

     output from parser-cmd (stderr):
       invalid integer: invalid digit found in string
       invalid integer: invalid digit found in string
       invalid integer: invalid digit found in string
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/integer/long
     Key "int64-max" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       # int64 "should" be supported, but is not mandatory. It's fine to skip this
       # test.
       int64-max     = 9223372036854775807
       int64-max-neg = -9223372036854775808

     output from parser-cmd (stdout):
       {
         "int64-max":     9223372036854775808,
         "int64-max-neg": -9223372036854775808
       }

     want:
       {
           "int64-max":     {"type": "integer", "value": "9223372036854775807"},
           "int64-max-neg": {"type": "integer", "value": "-9223372036854775808"}
       }

FAIL valid/integer/underscore
     invalid integer: invalid digit found in string
     invalid integer: invalid digit found in string
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       kilo = 1_000
       x = 1_1_1_1

     output from parser-cmd (stderr):
       invalid integer: invalid digit found in string
       invalid integer: invalid digit found in string
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/integer/zero
     Key "a2" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       d1 = 0
       d2 = +0
       d3 = -0

       h1 = 0x0
       h2 = 0x00
       h3 = 0x00000

       o1 = 0o0
       a2 = 0o00
       a3 = 0o00000

       b1 = 0b0
       b2 = 0b00
       b3 = 0b00000

     output from parser-cmd (stdout):
       {
         "a2": 0,
         "a3": 0,
         "b1": 0,
         "b2": 0,
         "b3": 0,
         "d1": 0,
         "d2": 0,
         "d3": 0,
         "h1": 0,
         "h2": 0,
         "h3": 0,
         "o1": 0
       }

     want:
       {
           "a2": {"type": "integer", "value": "0"},
           "a3": {"type": "integer", "value": "0"},
           "b1": {"type": "integer", "value": "0"},
           "b2": {"type": "integer", "value": "0"},
           "b3": {"type": "integer", "value": "0"},
           "d1": {"type": "integer", "value": "0"},
           "d2": {"type": "integer", "value": "0"},
           "d3": {"type": "integer", "value": "0"},
           "h1": {"type": "integer", "value": "0"},
           "h2": {"type": "integer", "value": "0"},
           "h3": {"type": "integer", "value": "0"},
           "o1": {"type": "integer", "value": "0"}
       }

FAIL valid/key/alphanum
     invalid number
     unknown line
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       alpha = "a"
       123 = "num"
       000111 = "leading"
       10e3 = "false float"
       one1two2 = "mixed"
       with-dash = "dashed"
       under_score = "___"
       34-11 = 23

       [2018_10]
       001 = 1

       [a-a-a]
       _ = false

     output from parser-cmd (stderr):
       invalid number
       unknown line
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/key/case-sensitive
     Key "Section.M" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       sectioN = "NN"

       [section]
       name = "lower"
       NAME = "upper"
       Name = "capitalized"

       [Section]
       name = "different section!!"
       "" = "greek small letter mu"
       "" = "greek capital letter MU"
       M = "latin letter M"

     output from parser-cmd (stdout):
       {
         "sectioN": "NN",
         "section": {"NAME": "upper", "Name": "capitalized", "name": "lower"},
         "Section": {
           "M":    "latin letter M",
           "name": "different section!!",
           "":    "greek capital letter MU",
           "":    "greek small letter mu"
         }
       }

     want:
       {
           "sectioN": {"type": "string", "value": "NN"},
           "Section": {
               "M":    {"type": "string", "value": "latin letter M"},
               "name": {"type": "string", "value": "different section!!"},
               "":    {"type": "string", "value": "greek capital letter MU"},
               "":    {"type": "string", "value": "greek small letter mu"}
           },
           "section": {
               "NAME": {"type": "string", "value": "upper"},
               "Name": {"type": "string", "value": "capitalized"},
               "name": {"type": "string", "value": "lower"}
           }
       }

FAIL valid/key/dotted-1
     Key "many.dots.dot.dot.dot" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       name.first = "Arthur"
       "name".'last' = "Dent"

       many.dots.dot.dot.dot = 42

     output from parser-cmd (stdout):
       {
         "name": {"first": "Arthur", "last": "Dent"},
         "many": {
           "dots": {
             "dot": {
               "dot": {"dot": 42}
             }
           }
         }
       }

     want:
       {
           "many": {
               "dots": {
                   "dot": {
                       "dot": {
                           "dot": {"type": "integer", "value": "42"}
                       }
                   }
               }
           },
           "name": {
               "first": {"type": "string", "value": "Arthur"},
               "last":  {"type": "string", "value": "Dent"}
           }
       }

FAIL valid/key/dotted-2
     Key "count.a" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       # Note: this file contains literal tab characters.

       # Space are ignored, and key parts can be quoted.
       count.a       = 1
       count . b     = 2
       "count"."c"   = 3
       "count" . "d" = 4
       'count'.'e'   = 5
       'count' . 'f' = 6
       "count".'g'   = 7
       "count" . 'h' = 8
       count.'i'     = 9
       count 	.	 'j'	   = 10
       "count".k     = 11
       "count" . l   = 12

     output from parser-cmd (stdout):
       {
         "count": {"a": 1, "b": 2, "c": 3, "d": 4, "e": 5, "f": 6, "g": 7, "h": 8, "i": 9, "j": 10, "k": 11, "l": 12}
       }

     want:
       {
           "count": {
               "a": {"type": "integer", "value": "1"},
               "b": {"type": "integer", "value": "2"},
               "c": {"type": "integer", "value": "3"},
               "d": {"type": "integer", "value": "4"},
               "e": {"type": "integer", "value": "5"},
               "f": {"type": "integer", "value": "6"},
               "g": {"type": "integer", "value": "7"},
               "h": {"type": "integer", "value": "8"},
               "i": {"type": "integer", "value": "9"},
               "j": {"type": "integer", "value": "10"},
               "k": {"type": "integer", "value": "11"},
               "l": {"type": "integer", "value": "12"}
           }
       }

FAIL valid/key/dotted-3
     Key "a.few.dots.polka.dance-with" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       top.key = 1

       [tbl]
       a.b.c = 42.666

       [a.few.dots]
       polka.dot = "again?"
       polka.dance-with = "Dot"

     output from parser-cmd (stdout):
       {
         "top": {"key": 1},
         "a": {
           "few": {
             "dots": {
               "polka": {"dance-with": "Dot", "dot": "again?"}
             }
           }
         },
         "tbl": {
           "a": {
             "b": {"c": 43}
           }
         }
       }

     want:
       {
           "a": {
               "few": {
                   "dots": {
                       "polka": {
                           "dance-with": {"type": "string", "value": "Dot"},
                           "dot":        {"type": "string", "value": "again?"}
                       }
                   }
               }
           },
           "tbl": {
               "a": {
                   "b": {
                       "c": {"type": "float", "value": "42.666"}
                   }
               }
           },
           "top": {
               "key": {"type": "integer", "value": "1"}
           }
       }

FAIL valid/key/dotted-4
     Key "arr.a.b.c" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       top.key = 1

       [[arr]]
       a.b.c=1
       a.b.d=2

       [[arr]]
       a.b.c=3
       a.b.d=4

     output from parser-cmd (stdout):
       {
         "top": {"key": 1},
         "arr": [
           {
             "a": {
               "b": {"c": 1, "d": 2}
             }
           },
           {
             "a": {
               "b": {"c": 3, "d": 4}
             }
           }
         ]
       }

     want:
       {
           "arr": [
               {
                   "a": {
                       "b": {
                           "c": {"type": "integer", "value": "1"},
                           "d": {"type": "integer", "value": "2"}
                       }
                   }
               },
               {
                   "a": {
                       "b": {
                           "c": {"type": "integer", "value": "3"},
                           "d": {"type": "integer", "value": "4"}
                       }
                   }
               }
           ],
           "top": {
               "key": {"type": "integer", "value": "1"}
           }
       }

FAIL valid/key/dotted-empty
     Key "x" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       ''.x = "empty.x"
       x."" = "x.empty"
       [a]
       "".'' = "empty.empty"

     output from parser-cmd (stdout):
       {
         "":  {"x": "empty.x"},
         "x": {"": "x.empty"},
         "a": {
           "": {"": "empty.empty"}
         }
       }

     want:
       {
           "": {
               "x": {"type": "string", "value": "empty.x"}
           },
           "a": {
               "": {
                   "": {"type": "string", "value": "empty.empty"}
               }
           },
           "x": {
               "": {"type": "string", "value": "x.empty"}
           }
       }

FAIL valid/key/empty-1
     Key "" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       "" = "blank"

     output from parser-cmd (stdout):
       {
         "": "blank"
       }

     want:
       {
           "": {"type": "string", "value": "blank"}
       }

FAIL valid/key/empty-2
     Key "" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       '' = "blank"

     output from parser-cmd (stdout):
       {
         "": "blank"
       }

     want:
       {
           "": {"type": "string", "value": "blank"}
       }

FAIL valid/key/empty-3
     Key "" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       ''=0

     output from parser-cmd (stdout):
       {
         "": 0
       }

     want:
       {
           "": {"type": "integer", "value": "0"}
       }

FAIL valid/key/equals-nospace
     Key "answer" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       answer=42

     output from parser-cmd (stdout):
       {
         "answer": 42
       }

     want:
       {
           "answer": {"type": "integer", "value": "42"}
       }

FAIL valid/key/escapes
     Could not find key "\b" in parser output.

     input sent to parser-cmd:
       "\n" = "newline"
       "\b" = "bell"
       "\u00c0" = "latin capital letter A with grave"
       "\"" = "just a quote"

       ["backsp\b\b"]

       ["\"quoted\""]
       quote = true

       ["a.b"."\u00c0"]

     output from parser-cmd (stdout):
       {
         "\"":         "just a quote",
         "\"quoted\"": {"quote": true},
         "\\b":        "bell",
         "\\n":        "newline",
         "\\u00c0":    "latin capital letter A with grave",
         "backsp\\b\\b": {},
         "a.b": {
           "\\u00c0": {}
         }
       }

     want:
       {
           "\b":         {"type": "string", "value": "bell"},
           "\n":         {"type": "string", "value": "newline"},
           "\"":         {"type": "string", "value": "just a quote"},
           "backsp\b\b": {},
           "":          {"type": "string", "value": "latin capital letter A with grave"},
           "\"quoted\"": {
               "quote": {"type": "bool", "value": "true"}
           },
           "a.b": {
               "": {}
           }
       }

FAIL valid/key/numeric
     Key "1" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       1 = 1

     output from parser-cmd (stdout):
       {
         "1": 1
       }

     want:
       {
           "1": {"type": "integer", "value": "1"}
       }

FAIL valid/key/numeric-dotted
     Could not find key "1" in parser output.

     input sent to parser-cmd:
       1.2 = 3

     output from parser-cmd (stdout):
       {}

     want:
       {
           "1": {
               "2": {"type": "integer", "value": "3"}
           }
       }

FAIL valid/key/quoted-dots
     Key "plain" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       plain = 1
       "with.dot" = 2

       [plain_table]
       plain = 3
       "with.dot" = 4

       [table.withdot]
       plain = 5
       "key.with.dots" = 6

     output from parser-cmd (stdout):
       {
         "plain":       1,
         "plain_table": {"plain": 3, "with.dot": 4},
         "with.dot":    2,
         "table": {
           "withdot": {"key.with.dots": 6, "plain": 5}
         }
       }

     want:
       {
           "plain":    {"type": "integer", "value": "1"},
           "with.dot": {"type": "integer", "value": "2"},
           "plain_table": {
               "plain":    {"type": "integer", "value": "3"},
               "with.dot": {"type": "integer", "value": "4"}
           },
           "table": {
               "withdot": {
                   "key.with.dots": {"type": "integer", "value": "6"},
                   "plain":         {"type": "integer", "value": "5"}
               }
           }
       }

FAIL valid/key/quoted-unicode
     duplicate key: \u0000
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:

       "\u0000" = "null"
       '\u0000' = "different key"
       "\u0008 \u000c \U00000041 \u007f \u0080 \u00ff \ud7ff \ue000 \uffff \U00010000 \U0010ffff" = "escaped key"

       "~       " = "basic key"
       'l ~       ' = "literal key"

     output from parser-cmd (stderr):
       duplicate key: \u0000
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/key/space
     Key " c d " (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       # Keep whitespace inside quotes keys at all positions.
       "a b"   = 1
       " c d " = 2

       [ " tbl " ]
       "\ttab\ttab\t" = "tab"

     output from parser-cmd (stdout):
       {
         " c d ": 2,
         " tbl ": {"\\ttab\\ttab\\t": "tab"},
         "a b":   1
       }

     want:
       {
           " c d ": {"type": "integer", "value": "2"},
           "a b":   {"type": "integer", "value": "1"},
           " tbl ": {
               "\ttab\ttab\t": {"type": "string", "value": "tab"}
           }
       }

FAIL valid/key/special-chars
     Key "=~!@$^&*()_+-`1234567890[]|/?><.,;:'=" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       "=~!@$^&*()_+-`1234567890[]|/?><.,;:'=" = 1

     output from parser-cmd (stdout):
       {
         "=~!@$^\u0026*()_+-`1234567890[]|/?\u003e\u003c.,;:'=": 1
       }

     want:
       {
           "=~!@$^\u0026*()_+-`1234567890[]|/?\u003e\u003c.,;:'=": {"type": "integer", "value": "1"}
       }

FAIL valid/key/special-word
     Could not find key "inf" in parser output.

     input sent to parser-cmd:
       false = false
       true = 1
       inf = 100000000
       nan = "ceci n'est pas un nombre"

     output from parser-cmd (stdout):
       {
         "false": false,
         "true":  1
       }

     want:
       {
           "false": {"type": "bool", "value": "false"},
           "inf":   {"type": "integer", "value": "100000000"},
           "nan":   {"type": "string", "value": "ceci n'est pas un nombre"},
           "true":  {"type": "integer", "value": "1"}
       }

FAIL valid/key/start
     invalid number
     invalid number
     invalid number
     invalid number
     invalid number
     invalid number
     invalid number
     invalid number
     invalid number
     invalid number
     expected key
     expected ']'
     expected key
     expected '='
     expected value
     expected key
     expected ']'
     expected key
     expected '='
     expected value
     expected key
     expected ']'
     expected key
     expected '='
     expected value
     expected key
     expected ']'
     expected key
     expected '='
     expected value
     expected key
     expected '='
     expected value
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       # Table and keys can start with any character; there is no requirement for it to
       # start with a letter.

       [-key]
       -key = 1

       [_key]
       _key = 2

       [1key]
       1key = 3

       [-]
       - = 4

       [_]
       _ = 5

       [1]
       1 = 6

       [---]
       --- = 7

       [___]
       ___ = 8

       [111]
       111 = 9

       [inline]
       --- = {--- = 10, ___ = 11, 111 = 12}

     output from parser-cmd (stderr):
       invalid number
       invalid number
       invalid number
       invalid number
       invalid number
       invalid number
       invalid number
       invalid number
       invalid number
       invalid number
       expected key
       expected ']'
       expected key
       expected '='
       expected value
       expected key
       expected ']'
       expected key
       expected '='
       expected value
       expected key
       expected ']'
       expected key
       expected '='
       expected value
       expected key
       expected ']'
       expected key
       expected '='
       expected value
       expected key
       expected '='
       expected value
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/key/zero
     Key "0" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       0=0

     output from parser-cmd (stdout):
       {
         "0": 0
       }

     want:
       {
           "0": {"type": "integer", "value": "0"}
       }

FAIL valid/newline-crlf
     Key "newline" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       os = "DOS"
       newline = "crlf"

     output from parser-cmd (stdout):
       {
         "newline": "crlf",
         "os":      "DOS"
       }

     want:
       {
           "newline": {"type": "string", "value": "crlf"},
           "os":      {"type": "string", "value": "DOS"}
       }

FAIL valid/newline-lf
     Key "newline" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       os = "unix"
       newline = "lf"

     output from parser-cmd (stdout):
       {
         "newline": "lf",
         "os":      "unix"
       }

     want:
       {
           "newline": {"type": "string", "value": "lf"},
           "os":      {"type": "string", "value": "unix"}
       }

FAIL valid/spec-example-1
     Key "clients.data" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       # This is a TOML document. Boom.

       title = "TOML Example"

       [owner]
       name = "Lance Uppercut"
       dob = 1979-05-27T07:32:00-08:00 # First class dates? Why not?

       [database]
       server = "192.168.1.1"
       ports = [ 8001, 8001, 8002 ]
       connection_max = 5000
       enabled = true

       [servers]

         # You can indent as you please. Tabs or spaces. TOML don't care.
         [servers.alpha]
         ip = "10.0.0.1"
         dc = "eqdc10"

         [servers.beta]
         ip = "10.0.0.2"
         dc = "eqdc10"

       [clients]
       data = [ ["gamma", "delta"], [1, 2] ]

       # Line breaks are OK when inside arrays
       hosts = [
         "alpha",
         "omega"
       ]

     output from parser-cmd (stdout):
       {
         "clients":  {"data": [
           ["gamma", "delta"],
           [1, 2]
         ], "hosts": ["alpha", "omega"]},
         "database": {"connection_max": 5000, "enabled": true, "ports": [8001, 8001, 8002], "server": "192.168.1.1"},
         "owner":    {"dob": "1979-05-27T07:32:00-08:00", "name": "Lance Uppercut"},
         "title":    "TOML Example",
         "servers": {
           "alpha": {"dc": "eqdc10", "ip": "10.0.0.1"},
           "beta":  {"dc": "eqdc10", "ip": "10.0.0.2"}
         }
       }

     want:
       {
           "title": {"type": "string", "value": "TOML Example"},
           "clients": {
               "data": [
                   [
                       {"type": "string", "value": "gamma"},
                       {"type": "string", "value": "delta"}
                   ],
                   [
                       {"type": "integer", "value": "1"},
                       {"type": "integer", "value": "2"}
                   ]
               ],
               "hosts": [
                   {"type": "string", "value": "alpha"},
                   {"type": "string", "value": "omega"}
               ]
           },
           "database": {
               "connection_max": {"type": "integer", "value": "5000"},
               "enabled":        {"type": "bool", "value": "true"},
               "server":         {"type": "string", "value": "192.168.1.1"},
               "ports": [
                   {"type": "integer", "value": "8001"},
                   {"type": "integer", "value": "8001"},
                   {"type": "integer", "value": "8002"}
               ]
           },
           "owner": {
               "dob":  {"type": "datetime", "value": "1979-05-27T07:32:00-08:00"},
               "name": {"type": "string", "value": "Lance Uppercut"}
           },
           "servers": {
               "alpha": {
                   "dc": {"type": "string", "value": "eqdc10"},
                   "ip": {"type": "string", "value": "10.0.0.1"}
               },
               "beta": {
                   "dc": {"type": "string", "value": "eqdc10"},
                   "ip": {"type": "string", "value": "10.0.0.2"}
               }
           }
       }

FAIL valid/spec-example-1-compact
     Key "clients.data" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       #Useless spaces eliminated.
       title="TOML Example"
       [owner]
       name="Lance Uppercut"
       dob=1979-05-27T07:32:00-08:00#First class dates
       [database]
       server="192.168.1.1"
       ports=[8001,8001,8002]
       connection_max=5000
       enabled=true
       [servers]
       [servers.alpha]
       ip="10.0.0.1"
       dc="eqdc10"
       [servers.beta]
       ip="10.0.0.2"
       dc="eqdc10"
       [clients]
       data=[["gamma","delta"],[1,2]]
       hosts=[
       "alpha",
       "omega"
       ]

     output from parser-cmd (stdout):
       {
         "clients":  {"data": [
           ["gamma", "delta"],
           [1, 2]
         ], "hosts": ["alpha", "omega"]},
         "database": {"connection_max": 5000, "enabled": true, "ports": [8001, 8001, 8002], "server": "192.168.1.1"},
         "owner":    {"dob": "1979-05-27T07:32:00-08:00", "name": "Lance Uppercut"},
         "title":    "TOML Example",
         "servers": {
           "alpha": {"dc": "eqdc10", "ip": "10.0.0.1"},
           "beta":  {"dc": "eqdc10", "ip": "10.0.0.2"}
         }
       }

     want:
       {
           "title": {"type": "string", "value": "TOML Example"},
           "clients": {
               "data": [
                   [
                       {"type": "string", "value": "gamma"},
                       {"type": "string", "value": "delta"}
                   ],
                   [
                       {"type": "integer", "value": "1"},
                       {"type": "integer", "value": "2"}
                   ]
               ],
               "hosts": [
                   {"type": "string", "value": "alpha"},
                   {"type": "string", "value": "omega"}
               ]
           },
           "database": {
               "connection_max": {"type": "integer", "value": "5000"},
               "enabled":        {"type": "bool", "value": "true"},
               "server":         {"type": "string", "value": "192.168.1.1"},
               "ports": [
                   {"type": "integer", "value": "8001"},
                   {"type": "integer", "value": "8001"},
                   {"type": "integer", "value": "8002"}
               ]
           },
           "owner": {
               "dob":  {"type": "datetime", "value": "1979-05-27T07:32:00-08:00"},
               "name": {"type": "string", "value": "Lance Uppercut"}
           },
           "servers": {
               "alpha": {
                   "dc": {"type": "string", "value": "eqdc10"},
                   "ip": {"type": "string", "value": "10.0.0.1"}
               },
               "beta": {
                   "dc": {"type": "string", "value": "eqdc10"},
                   "ip": {"type": "string", "value": "10.0.0.2"}
               }
           }
       }

FAIL valid/spec/array-0
     Key "colors" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       integers = [ 1, 2, 3 ]
       colors = [ "red", "yellow", "green" ]
       nested_arrays_of_ints = [ [ 1, 2 ], [3, 4, 5] ]
       nested_mixed_array = [ [ 1, 2 ], ["a", "b", "c"] ]
       string_array = [ "all", 'strings', """are the same""", '''type''' ]

       # Mixed-type arrays are allowed
       numbers = [ 0.1, 0.2, 0.5, 1, 2, 5 ]
       contributors = [
         "Foo Bar <foo@example.com>",
         { name = "Baz Qux", email = "bazqux@example.com", url = "https://example.com/bazqux" }
       ]

     output from parser-cmd (stdout):
       {
         "colors":       ["red", "yellow", "green"],
         "integers":     [1, 2, 3],
         "numbers":      [0, 0, 0, 1, 2, 5],
         "string_array": ["all", "strings", "are the same", "type"],
         "contributors": [
           "Foo Bar \u003cfoo@example.com\u003e",
           {"email": "bazqux@example.com", "name": "Baz Qux", "url": "https://example.com/bazqux"}
         ],
         "nested_arrays_of_ints": [
           [1, 2],
           [3, 4, 5]
         ],
         "nested_mixed_array": [
           [1, 2],
           ["a", "b", "c"]
         ]
       }

     want:
       {
           "colors": [
               {"type": "string", "value": "red"},
               {"type": "string", "value": "yellow"},
               {"type": "string", "value": "green"}
           ],
           "contributors": [
               {"type": "string", "value": "Foo Bar \u003cfoo@example.com\u003e"},
               {
                   "email": {"type": "string", "value": "bazqux@example.com"},
                   "name":  {"type": "string", "value": "Baz Qux"},
                   "url":   {"type": "string", "value": "https://example.com/bazqux"}
               }
           ],
           "integers": [
               {"type": "integer", "value": "1"},
               {"type": "integer", "value": "2"},
               {"type": "integer", "value": "3"}
           ],
           "nested_arrays_of_ints": [
               [
                   {"type": "integer", "value": "1"},
                   {"type": "integer", "value": "2"}
               ],
               [
                   {"type": "integer", "value": "3"},
                   {"type": "integer", "value": "4"},
                   {"type": "integer", "value": "5"}
               ]
           ],
           "nested_mixed_array": [
               [
                   {"type": "integer", "value": "1"},
                   {"type": "integer", "value": "2"}
               ],
               [
                   {"type": "string", "value": "a"},
                   {"type": "string", "value": "b"},
                   {"type": "string", "value": "c"}
               ]
           ],
           "numbers": [
               {"type": "float", "value": "0.1"},
               {"type": "float", "value": "0.2"},
               {"type": "float", "value": "0.5"},
               {"type": "integer", "value": "1"},
               {"type": "integer", "value": "2"},
               {"type": "integer", "value": "5"}
           ],
           "string_array": [
               {"type": "string", "value": "all"},
               {"type": "string", "value": "strings"},
               {"type": "string", "value": "are the same"},
               {"type": "string", "value": "type"}
           ]
       }

FAIL valid/spec/array-1
     Key "integers2" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       integers2 = [
         1, 2, 3
       ]

       integers3 = [
         1,
         2, # this is ok
       ]

     output from parser-cmd (stdout):
       {
         "integers2": [1, 2, 3],
         "integers3": [1, 2]
       }

     want:
       {
           "integers2": [
               {"type": "integer", "value": "1"},
               {"type": "integer", "value": "2"},
               {"type": "integer", "value": "3"}
           ],
           "integers3": [
               {"type": "integer", "value": "1"},
               {"type": "integer", "value": "2"}
           ]
       }

FAIL valid/spec/array-of-tables-0
     Key "products.name" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       [[products]]
       name = "Hammer"
       sku = 738594937

       [[products]]  # empty table within the array

       [[products]]
       name = "Nail"
       sku = 284758393

       color = "gray"

     output from parser-cmd (stdout):
       {
         "products": [
           {"name": "Hammer", "sku": 738594937},
           {},
           {"color": "gray", "name": "Nail", "sku": 284758393}
         ]
       }

     want:
       {
           "products": [
               {
                   "name": {"type": "string", "value": "Hammer"},
                   "sku":  {"type": "integer", "value": "738594937"}
               },
               {},
               {
                   "color": {"type": "string", "value": "gray"},
                   "name":  {"type": "string", "value": "Nail"},
                   "sku":   {"type": "integer", "value": "284758393"}
               }
           ]
       }

FAIL valid/spec/array-of-tables-1
     Key "fruits.name" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       [[fruits]]
       name = "apple"

       [fruits.physical]  # subtable
       color = "red"
       shape = "round"

       [[fruits.varieties]]  # nested array of tables
       name = "red delicious"

       [[fruits.varieties]]
       name = "granny smith"


       [[fruits]]
       name = "banana"

       [[fruits.varieties]]
       name = "plantain"

     output from parser-cmd (stdout):
       {
         "fruits": [
           {
             "name":     "apple",
             "physical": {"color": "red", "shape": "round"},
             "varieties": [
               {"name": "red delicious"},
               {"name": "granny smith"}
             ]
           },
           {"name": "banana", "varieties": [{"name": "plantain"}]}
         ]
       }

     want:
       {
           "fruits": [
               {
                   "name": {"type": "string", "value": "apple"},
                   "physical": {
                       "color": {"type": "string", "value": "red"},
                       "shape": {"type": "string", "value": "round"}
                   },
                   "varieties": [
                       {
                           "name": {"type": "string", "value": "red delicious"}
                       },
                       {
                           "name": {"type": "string", "value": "granny smith"}
                       }
                   ]
               },
               {
                   "name":      {"type": "string", "value": "banana"},
                   "varieties": [{
                       "name": {"type": "string", "value": "plantain"}
                   }]
               }
           ]
       }

FAIL valid/spec/array-of-tables-2
     Key "points.x" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       points = [ { x = 1, y = 2, z = 3 },
                  { x = 7, y = 8, z = 9 },
                  { x = 2, y = 4, z = 8 } ]

     output from parser-cmd (stdout):
       {
         "points": [
           {"x": 1, "y": 2, "z": 3},
           {"x": 7, "y": 8, "z": 9},
           {"x": 2, "y": 4, "z": 8}
         ]
       }

     want:
       {
           "points": [
               {
                   "x": {"type": "integer", "value": "1"},
                   "y": {"type": "integer", "value": "2"},
                   "z": {"type": "integer", "value": "3"}
               },
               {
                   "x": {"type": "integer", "value": "7"},
                   "y": {"type": "integer", "value": "8"},
                   "z": {"type": "integer", "value": "9"}
               },
               {
                   "x": {"type": "integer", "value": "2"},
                   "y": {"type": "integer", "value": "4"},
                   "z": {"type": "integer", "value": "8"}
               }
           ]
       }

FAIL valid/spec/boolean-0
     Key "bool1" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       bool1 = true
       bool2 = false

     output from parser-cmd (stdout):
       {
         "bool1": true,
         "bool2": false
       }

     want:
       {
           "bool1": {"type": "bool", "value": "true"},
           "bool2": {"type": "bool", "value": "false"}
       }

FAIL valid/spec/comment-0
     Key "another" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       # This is a full-line comment
       key = "value"  # This is a comment at the end of a line
       another = "# This is not a comment"

     output from parser-cmd (stdout):
       {
         "another": "# This is not a comment",
         "key":     "value"
       }

     want:
       {
           "another": {"type": "string", "value": "# This is not a comment"},
           "key":     {"type": "string", "value": "value"}
       }

FAIL valid/spec/float-0
     Key "flt1" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       # fractional
       flt1 = +1.0
       flt2 = 3.1415
       flt3 = -0.01

       # exponent
       flt4 = 5e+22
       flt5 = 1e06
       flt6 = -2E-2

       # both
       flt7 = 6.626e-34

     output from parser-cmd (stdout):
       {
         "flt1": 1,
         "flt2": 3,
         "flt3": -0,
         "flt4": 49999999999999995805696,
         "flt5": 1000000,
         "flt6": -0,
         "flt7": 0
       }

     want:
       {
           "flt1": {"type": "float", "value": "1"},
           "flt2": {"type": "float", "value": "3.1415"},
           "flt3": {"type": "float", "value": "-0.01"},
           "flt4": {"type": "float", "value": "5e+22"},
           "flt5": {"type": "float", "value": "1e+06"},
           "flt6": {"type": "float", "value": "-0.02"},
           "flt7": {"type": "float", "value": "6.626e-34"}
       }

FAIL valid/spec/float-1
     invalid float: invalid float literal
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       flt8 = 224_617.445_991_228

     output from parser-cmd (stderr):
       invalid float: invalid float literal
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/spec/float-2
     Key "sf1" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       # infinity
       sf1 = inf  # positive infinity
       sf2 = +inf # positive infinity
       sf3 = -inf # negative infinity

       # not a number
       sf4 = nan  # actual sNaN/qNaN encoding is implementation-specific
       sf5 = +nan # same as `nan`
       sf6 = -nan # valid, actual encoding is implementation-specific

     output from parser-cmd (stdout):
       {
         "sf1": null,
         "sf2": null,
         "sf3": null,
         "sf4": null,
         "sf5": null,
         "sf6": null
       }

     want:
       {
           "sf1": {"type": "float", "value": "inf"},
           "sf2": {"type": "float", "value": "inf"},
           "sf3": {"type": "float", "value": "-inf"},
           "sf4": {"type": "float", "value": "nan"},
           "sf5": {"type": "float", "value": "nan"},
           "sf6": {"type": "float", "value": "nan"}
       }

FAIL valid/spec/inline-table-0
     Key "animal.type.name" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       name = { first = "Tom", last = "Preston-Werner" }
       point = { x = 1, y = 2 }
       animal = { type.name = "pug" }

     output from parser-cmd (stdout):
       {
         "name":  {"first": "Tom", "last": "Preston-Werner"},
         "point": {"x": 1, "y": 2},
         "animal": {
           "type": {"name": "pug"}
         }
       }

     want:
       {
           "animal": {
               "type": {
                   "name": {"type": "string", "value": "pug"}
               }
           },
           "name": {
               "first": {"type": "string", "value": "Tom"},
               "last":  {"type": "string", "value": "Preston-Werner"}
           },
           "point": {
               "x": {"type": "integer", "value": "1"},
               "y": {"type": "integer", "value": "2"}
           }
       }

FAIL valid/spec/inline-table-1
     Key "animal.type.name" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       [name]
       first = "Tom"
       last = "Preston-Werner"

       [point]
       x = 1
       y = 2

       [animal]
       type.name = "pug"

     output from parser-cmd (stdout):
       {
         "name":  {"first": "Tom", "last": "Preston-Werner"},
         "point": {"x": 1, "y": 2},
         "animal": {
           "type": {"name": "pug"}
         }
       }

     want:
       {
           "animal": {
               "type": {
                   "name": {"type": "string", "value": "pug"}
               }
           },
           "name": {
               "first": {"type": "string", "value": "Tom"},
               "last":  {"type": "string", "value": "Preston-Werner"}
           },
           "point": {
               "x": {"type": "integer", "value": "1"},
               "y": {"type": "integer", "value": "2"}
           }
       }

FAIL valid/spec/inline-table-2
     Key "product.type.name" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       [product]
       type = { name = "Nail" }
       # type.edible = false  # INVALID

     output from parser-cmd (stdout):
       {
         "product": {
           "type": {"name": "Nail"}
         }
       }

     want:
       {
           "product": {
               "type": {
                   "name": {"type": "string", "value": "Nail"}
               }
           }
       }

FAIL valid/spec/inline-table-3
     Key "product.type.name" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       [product]
       type.name = "Nail"
       # type = { edible = false }  # INVALID

     output from parser-cmd (stdout):
       {
         "product": {
           "type": {"name": "Nail"}
         }
       }

     want:
       {
           "product": {
               "type": {
                   "name": {"type": "string", "value": "Nail"}
               }
           }
       }

FAIL valid/spec/integer-0
     Key "int1" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       int1 = +99
       int2 = 42
       int3 = 0
       int4 = -17

     output from parser-cmd (stdout):
       {
         "int1": 99,
         "int2": 42,
         "int3": 0,
         "int4": -17
       }

     want:
       {
           "int1": {"type": "integer", "value": "99"},
           "int2": {"type": "integer", "value": "42"},
           "int3": {"type": "integer", "value": "0"},
           "int4": {"type": "integer", "value": "-17"}
       }

FAIL valid/spec/integer-1
     invalid integer: invalid digit found in string
     invalid integer: invalid digit found in string
     invalid integer: invalid digit found in string
     invalid integer: invalid digit found in string
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       int5 = 1_000
       int6 = 5_349_221
       int7 = 53_49_221  # Indian number system grouping
       int8 = 1_2_3_4_5  # VALID but discouraged

     output from parser-cmd (stderr):
       invalid integer: invalid digit found in string
       invalid integer: invalid digit found in string
       invalid integer: invalid digit found in string
       invalid integer: invalid digit found in string
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/spec/integer-2
     invalid integer: invalid digit found in string
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       # hexadecimal with prefix `0x`
       hex1 = 0xDEADBEEF
       hex2 = 0xdeadbeef
       hex3 = 0xdead_beef

       # octal with prefix `0o`
       oct1 = 0o01234567
       oct2 = 0o755 # useful for Unix file permissions

       # binary with prefix `0b`
       bin1 = 0b11010110

     output from parser-cmd (stderr):
       invalid integer: invalid digit found in string
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/spec/key-value-pair-0
     Key "key" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       key = "value"

     output from parser-cmd (stdout):
       {
         "key": "value"
       }

     want:
       {
           "key": {"type": "string", "value": "value"}
       }

FAIL valid/spec/keys-0
     Key "1234" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       key = "value"
       bare_key = "value"
       bare-key = "value"
       1234 = "value"

     output from parser-cmd (stdout):
       {
         "1234":     "value",
         "bare-key": "value",
         "bare_key": "value",
         "key":      "value"
       }

     want:
       {
           "1234":     {"type": "string", "value": "value"},
           "bare-key": {"type": "string", "value": "value"},
           "bare_key": {"type": "string", "value": "value"},
           "key":      {"type": "string", "value": "value"}
       }

FAIL valid/spec/keys-1
     Key "127.0.0.1" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       "127.0.0.1" = "value"
       "character encoding" = "value"
       "" = "value"
       'key2' = "value"
       'quoted "value"' = "value"

     output from parser-cmd (stdout):
       {
         "127.0.0.1":          "value",
         "character encoding": "value",
         "key2":               "value",
         "quoted \"value\"":   "value",
         "":                "value"
       }

     want:
       {
           "127.0.0.1":          {"type": "string", "value": "value"},
           "character encoding": {"type": "string", "value": "value"},
           "key2":               {"type": "string", "value": "value"},
           "quoted \"value\"":   {"type": "string", "value": "value"},
           "":                {"type": "string", "value": "value"}
       }

FAIL valid/spec/keys-3
     Key "name" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       name = "Orange"
       physical.color = "orange"
       physical.shape = "round"
       site."google.com" = true

     output from parser-cmd (stdout):
       {
         "name":     "Orange",
         "physical": {"color": "orange", "shape": "round"},
         "site":     {"google.com": true}
       }

     want:
       {
           "name": {"type": "string", "value": "Orange"},
           "physical": {
               "color": {"type": "string", "value": "orange"},
               "shape": {"type": "string", "value": "round"}
           },
           "site": {
               "google.com": {"type": "bool", "value": "true"}
           }
       }

FAIL valid/spec/keys-4
     Key "fruit.color" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       fruit.name = "banana"     # this is best practice
       fruit. color = "yellow"    # same as fruit.color
       fruit . flavor = "banana"   # same as fruit.flavor

     output from parser-cmd (stdout):
       {
         "fruit": {"color": "yellow", "flavor": "banana", "name": "banana"}
       }

     want:
       {
           "fruit": {
               "color":  {"type": "string", "value": "yellow"},
               "flavor": {"type": "string", "value": "banana"},
               "name":   {"type": "string", "value": "banana"}
           }
       }

FAIL valid/spec/keys-5
     Key "apple.color" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       # VALID BUT DISCOURAGED

       apple.type = "fruit"
       orange.type = "fruit"

       apple.skin = "thin"
       orange.skin = "thick"

       apple.color = "red"
       orange.color = "orange"

     output from parser-cmd (stdout):
       {
         "apple":  {"color": "red", "skin": "thin", "type": "fruit"},
         "orange": {"color": "orange", "skin": "thick", "type": "fruit"}
       }

     want:
       {
           "apple": {
               "color": {"type": "string", "value": "red"},
               "skin":  {"type": "string", "value": "thin"},
               "type":  {"type": "string", "value": "fruit"}
           },
           "orange": {
               "color": {"type": "string", "value": "orange"},
               "skin":  {"type": "string", "value": "thick"},
               "type":  {"type": "string", "value": "fruit"}
           }
       }

FAIL valid/spec/keys-6
     Key "apple.color" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       # RECOMMENDED

       apple.type = "fruit"
       apple.skin = "thin"
       apple.color = "red"

       orange.type = "fruit"
       orange.skin = "thick"
       orange.color = "orange"

     output from parser-cmd (stdout):
       {
         "apple":  {"color": "red", "skin": "thin", "type": "fruit"},
         "orange": {"color": "orange", "skin": "thick", "type": "fruit"}
       }

     want:
       {
           "apple": {
               "color": {"type": "string", "value": "red"},
               "skin":  {"type": "string", "value": "thin"},
               "type":  {"type": "string", "value": "fruit"}
           },
           "orange": {
               "color": {"type": "string", "value": "orange"},
               "skin":  {"type": "string", "value": "thick"},
               "type":  {"type": "string", "value": "fruit"}
           }
       }

FAIL valid/spec/keys-7
     Could not find key "3" in parser output.

     input sent to parser-cmd:
       3.14159 = "pi"

     output from parser-cmd (stdout):
       {}

     want:
       {
           "3": {
               "14159": {"type": "string", "value": "pi"}
           }
       }

FAIL valid/spec/local-date-0
     Key "ld1" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       ld1 = 1979-05-27

     output from parser-cmd (stdout):
       {
         "ld1": "1979-05-27"
       }

     want:
       {
           "ld1": {"type": "date-local", "value": "1979-05-27"}
       }

FAIL valid/spec/local-date-time-0
     Key "ldt1" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       ldt1 = 1979-05-27T07:32:00
       ldt2 = 1979-05-27T00:32:00.999

     output from parser-cmd (stdout):
       {
         "ldt1": "1979-05-27T07:32:00",
         "ldt2": "1979-05-27T00:32:00.999"
       }

     want:
       {
           "ldt1": {"type": "datetime-local", "value": "1979-05-27T07:32:00"},
           "ldt2": {"type": "datetime-local", "value": "1979-05-27T00:32:00.999"}
       }

FAIL valid/spec/local-time-0
     Key "lt1" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       lt1 = 07:32:00
       lt2 = 00:32:00.999

     output from parser-cmd (stdout):
       {
         "lt1": "07:32:00",
         "lt2": "00:32:00.999"
       }

     want:
       {
           "lt1": {"type": "time-local", "value": "07:32:00"},
           "lt2": {"type": "time-local", "value": "00:32:00.999"}
       }

FAIL valid/spec/offset-date-time-0
     Key "odt1" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       odt1 = 1979-05-27T07:32:00Z
       odt2 = 1979-05-27T00:32:00-07:00
       odt3 = 1979-05-27T00:32:00.999-07:00

     output from parser-cmd (stdout):
       {
         "odt1": "1979-05-27T07:32:00Z",
         "odt2": "1979-05-27T00:32:00-07:00",
         "odt3": "1979-05-27T00:32:00.999-07:00"
       }

     want:
       {
           "odt1": {"type": "datetime", "value": "1979-05-27T07:32:00Z"},
           "odt2": {"type": "datetime", "value": "1979-05-27T00:32:00-07:00"},
           "odt3": {"type": "datetime", "value": "1979-05-27T00:32:00.999-07:00"}
       }

FAIL valid/spec/offset-date-time-1
     Key "odt4" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       odt4 = 1979-05-27 07:32:00Z

     output from parser-cmd (stdout):
       {
         "odt4": "1979-05-27T07:32:00Z"
       }

     want:
       {
           "odt4": {"type": "datetime", "value": "1979-05-27T07:32:00Z"}
       }

FAIL valid/spec/string-0
     Key "str" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       str = "I'm a string. \"You can quote me\". Name\tJos\u00E9\nLocation\tSF."

     output from parser-cmd (stdout):
       {
         "str": "I'm a string. \"You can quote me\". Name\\tJos\\u00E9\\nLocation\\tSF."
       }

     want:
       {
           "str": {"type": "string", "value": "I'm a string. \"You can quote me\". Name\tJos\nLocation\tSF."}
       }

FAIL valid/spec/string-1
     Key "str1" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       str1 = """
       Roses are red
       Violets are blue"""

     output from parser-cmd (stdout):
       {
         "str1": "\nRoses are red\nViolets are blue"
       }

     want:
       {
           "str1": {"type": "string", "value": "Roses are red\nViolets are blue"}
       }

FAIL valid/spec/string-2
     Key "str2" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       # On a Unix system, the above multi-line string will most likely be the same as:
       str2 = "Roses are red\nViolets are blue"

       # On a Windows system, it will most likely be equivalent to:
       str3 = "Roses are red\r\nViolets are blue"

     output from parser-cmd (stdout):
       {
         "str2": "Roses are red\\nViolets are blue",
         "str3": "Roses are red\\r\\nViolets are blue"
       }

     want:
       {
           "str2": {"type": "string", "value": "Roses are red\nViolets are blue"},
           "str3": {"type": "string", "value": "Roses are red\r\nViolets are blue"}
       }

FAIL valid/spec/string-3
     Key "str1" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       # The following strings are byte-for-byte equivalent:
       str1 = "The quick brown fox jumps over the lazy dog."

       str2 = """
       The quick brown \


         fox jumps over \
           the lazy dog."""

       str3 = """\
              The quick brown \
              fox jumps over \
              the lazy dog.\
              """

     output from parser-cmd (stdout):
       {
         "str1": "The quick brown fox jumps over the lazy dog.",
         "str2": "\nThe quick brown \\\n\n\n  fox jumps over \\\n    the lazy dog.",
         "str3": "\\\n       The quick brown \\\n       fox jumps over \\\n       the lazy dog.\\\n       "
       }

     want:
       {
           "str1": {"type": "string", "value": "The quick brown fox jumps over the lazy dog."},
           "str2": {"type": "string", "value": "The quick brown fox jumps over the lazy dog."},
           "str3": {"type": "string", "value": "The quick brown fox jumps over the lazy dog."}
       }

FAIL valid/spec/string-4
     invalid token
     invalid multi-line basic strings
     unknown line
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       str4 = """Here are two quotation marks: "". Simple enough."""
       # str5 = """Here are three quotation marks: """."""  # INVALID
       str5 = """Here are three quotation marks: ""\"."""
       str6 = """Here are fifteen quotation marks: ""\"""\"""\"""\"""\"."""

       # "This," she said, "is just a pointless statement."
       str7 = """"This," she said, "is just a pointless statement.""""

     output from parser-cmd (stderr):
       invalid token
       invalid multi-line basic strings
       unknown line
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/spec/string-5
     invalid key
     expected '='
     unknown line
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       # What you see is what you get.
       winpath  = 'C:\Users\nodejs\templates'
       winpath2 = '\\ServerX\admin$\system32\'
       quoted   = 'Tom "Dubs" Preston-Werner'
       regex    = '<\i\c*\s*>'

     output from parser-cmd (stderr):
       invalid key
       expected '='
       unknown line
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/spec/string-6
     Key "lines" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       regex2 = '''I [dw]on't need \d{2} apples'''
       lines  = '''
       The first newline is
       trimmed in raw strings.
          All other whitespace
          is preserved.
       '''

     output from parser-cmd (stdout):
       {
         "lines":  "\nThe first newline is\ntrimmed in raw strings.\n   All other whitespace\n   is preserved.\n",
         "regex2": "I [dw]on't need \\d{2} apples"
       }

     want:
       {
           "lines":  {"type": "string", "value": "The first newline is\ntrimmed in raw strings.\n   All other whitespace\n   is preserved.\n"},
           "regex2": {"type": "string", "value": "I [dw]on't need \\d{2} apples"}
       }

FAIL valid/spec/string-7
     expected '='
     expected value
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       quot15 = '''Here are fifteen quotation marks: """""""""""""""'''

       # apos15 = '''Here are fifteen apostrophes: ''''''''''''''''''  # INVALID
       apos15 = "Here are fifteen apostrophes: '''''''''''''''"

       # 'That,' she said, 'is still pointless.'
       str = ''''That,' she said, 'is still pointless.''''

     output from parser-cmd (stderr):
       expected '='
       expected value
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/spec/table-1
     Key "table-1.key1" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       [table-1]
       key1 = "some string"
       key2 = 123

       [table-2]
       key1 = "another string"
       key2 = 456

     output from parser-cmd (stdout):
       {
         "table-1": {"key1": "some string", "key2": 123},
         "table-2": {"key1": "another string", "key2": 456}
       }

     want:
       {
           "table-1": {
               "key1": {"type": "string", "value": "some string"},
               "key2": {"type": "integer", "value": "123"}
           },
           "table-2": {
               "key1": {"type": "string", "value": "another string"},
               "key2": {"type": "integer", "value": "456"}
           }
       }

FAIL valid/spec/table-2
     Key "dog.tater.man.type.name" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       [dog."tater.man"]
       type.name = "pug"

     output from parser-cmd (stdout):
       {
         "dog": {
           "tater.man": {
             "type": {"name": "pug"}
           }
         }
       }

     want:
       {
           "dog": {
               "tater.man": {
                   "type": {
                       "name": {"type": "string", "value": "pug"}
                   }
               }
           }
       }

FAIL valid/spec/table-7
     Key "breed" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       # Top-level table begins.
       name = "Fido"
       breed = "pug"

       # Top-level table ends.
       [owner]
       name = "Regina Dogman"
       member_since = 1999-08-04

     output from parser-cmd (stdout):
       {
         "breed": "pug",
         "name":  "Fido",
         "owner": {"member_since": "1999-08-04", "name": "Regina Dogman"}
       }

     want:
       {
           "breed": {"type": "string", "value": "pug"},
           "name":  {"type": "string", "value": "Fido"},
           "owner": {
               "member_since": {"type": "date-local", "value": "1999-08-04"},
               "name":         {"type": "string", "value": "Regina Dogman"}
           }
       }

FAIL valid/spec/table-8
     Key "fruit.apple.color" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       fruit.apple.color = "red"
       # Defines a table named fruit
       # Defines a table named fruit.apple

       fruit.apple.taste.sweet = true
       # Defines a table named fruit.apple.taste
       # fruit and fruit.apple were already created

     output from parser-cmd (stdout):
       {
         "fruit": {
           "apple": {
             "color": "red",
             "taste": {"sweet": true}
           }
         }
       }

     want:
       {
           "fruit": {
               "apple": {
                   "color": {"type": "string", "value": "red"},
                   "taste": {
                       "sweet": {"type": "bool", "value": "true"}
                   }
               }
           }
       }

FAIL valid/spec/table-9
     Key "fruit.apple.color" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       [fruit]
       apple.color = "red"
       apple.taste.sweet = true

       # [fruit.apple]  # INVALID
       # [fruit.apple.taste]  # INVALID

       [fruit.apple.texture]  # you can add sub-tables
       smooth = true

     output from parser-cmd (stdout):
       {
         "fruit": {
           "apple": {
             "color":   "red",
             "taste":   {"sweet": true},
             "texture": {"smooth": true}
           }
         }
       }

     want:
       {
           "fruit": {
               "apple": {
                   "color": {"type": "string", "value": "red"},
                   "taste": {
                       "sweet": {"type": "bool", "value": "true"}
                   },
                   "texture": {
                       "smooth": {"type": "bool", "value": "true"}
                   }
               }
           }
       }

FAIL valid/string/double-quote-escape
     Key "test" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       test = "\"one\""

     output from parser-cmd (stdout):
       {
         "test": "\"one\""
       }

     want:
       {
           "test": {"type": "string", "value": "\"one\""}
       }

FAIL valid/string/empty
     Key "answer" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       answer = ""

     output from parser-cmd (stdout):
       {
         "answer": ""
       }

     want:
       {
           "answer": {"type": "string", "value": ""}
       }

FAIL valid/string/ends-in-whitespace-escape
     Key "beee" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       beee = """
       heeee
       geeee\


             """

     output from parser-cmd (stdout):
       {
         "beee": "\nheeee\ngeeee\\  \n\n\n      "
       }

     want:
       {
           "beee": {"type": "string", "value": "heeee\ngeeee"}
       }

FAIL valid/string/escape-tricky
     invalid basic string
     invalid token
     invalid key
     expected value
     unknown line
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       end_esc = "String does not end here\" but ends here\\"
       lit_end_esc = 'String ends here\'

       multiline_unicode = """
       \u00a0"""

       multiline_not_unicode = """
       \\u0041"""

       multiline_end_esc = """When will it end? \"""...""\" should be here\""""

       lit_multiline_not_unicode = '''
       \u007f'''

       lit_multiline_end = '''There is no escape\'''

     output from parser-cmd (stderr):
       invalid basic string
       invalid token
       invalid key
       expected value
       unknown line
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/string/escaped-escape
     Key "answer" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       answer = "\\x64"

     output from parser-cmd (stdout):
       {
         "answer": "\\\\x64"
       }

     want:
       {
           "answer": {"type": "string", "value": "\\x64"}
       }

FAIL valid/string/escapes
     Key "backslash" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       backspace     = "|\b."
       tab           = "|\t."
       newline       = "|\n."
       formfeed      = "|\f."
       carriage      = "|\r."
       quote         = "|\"."
       backslash     = "|\\."
       delete        = "|\u007F."
       unitseparator = "|\u001F."

       # \u is escaped, so should NOT be interperted as a \u escape.
       notunicode1   = "|\\u."
       notunicode2   = "|\u005Cu."
       notunicode3   = "|\\u0075."
       notunicode4   = "|\\\u0075."

     output from parser-cmd (stdout):
       {
         "backslash":     "|\\\\.",
         "backspace":     "|\\b.",
         "carriage":      "|\\r.",
         "delete":        "|\\u007F.",
         "formfeed":      "|\\f.",
         "newline":       "|\\n.",
         "notunicode1":   "|\\\\u.",
         "notunicode2":   "|\\u005Cu.",
         "notunicode3":   "|\\\\u0075.",
         "notunicode4":   "|\\\\\\u0075.",
         "quote":         "|\".",
         "tab":           "|\\t.",
         "unitseparator": "|\\u001F."
       }

     want:
       {
           "backslash":     {"type": "string", "value": "|\\."},
           "backspace":     {"type": "string", "value": "|\b."},
           "carriage":      {"type": "string", "value": "|\r."},
           "delete":        {"type": "string", "value": "|."},
           "formfeed":      {"type": "string", "value": "|\f."},
           "newline":       {"type": "string", "value": "|\n."},
           "notunicode1":   {"type": "string", "value": "|\\u."},
           "notunicode2":   {"type": "string", "value": "|\\u."},
           "notunicode3":   {"type": "string", "value": "|\\u0075."},
           "notunicode4":   {"type": "string", "value": "|\\u."},
           "quote":         {"type": "string", "value": "|\"."},
           "tab":           {"type": "string", "value": "|\t."},
           "unitseparator": {"type": "string", "value": "|\u001f."}
       }

FAIL valid/string/multiline
     Key "equivalent_one" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       # NOTE: this file includes some literal tab characters.

       equivalent_one = "The quick brown fox jumps over the lazy dog."
       equivalent_two = """
       The quick brown \


         fox jumps over \
           the lazy dog."""

       equivalent_three = """\
              The quick brown \
              fox jumps over \
              the lazy dog.\
              """

       whitespace-after-bs = """\
              The quick brown \
              fox jumps over \
              the lazy dog.\
              """

       no-space = """a\
           b"""

       # Has tab character.
       keep-ws-before = """a   	\
          b"""

       escape-bs-1 = """a \\
       b"""

       escape-bs-2 = """a \\\
       b"""

       escape-bs-3 = """a \\\\
         b"""

     output from parser-cmd (stdout):
       {
         "equivalent_one":      "The quick brown fox jumps over the lazy dog.",
         "equivalent_three":    "\\\n       The quick brown \\\n       fox jumps over \\\n       the lazy dog.\\\n       ",
         "equivalent_two":      "\nThe quick brown \\\n\n\n  fox jumps over \\\n    the lazy dog.",
         "escape-bs-1":         "a \\\\\nb",
         "escape-bs-2":         "a \\\\\\\nb",
         "escape-bs-3":         "a \\\\\\\\\n  b",
         "keep-ws-before":      "a   \t\\\n   b",
         "no-space":            "a\\\n    b",
         "whitespace-after-bs": "\\\n       The quick brown \\\n       fox jumps over \\   \n       the lazy dog.\\\t\n       "
       }

     want:
       {
           "equivalent_one":      {"type": "string", "value": "The quick brown fox jumps over the lazy dog."},
           "equivalent_three":    {"type": "string", "value": "The quick brown fox jumps over the lazy dog."},
           "equivalent_two":      {"type": "string", "value": "The quick brown fox jumps over the lazy dog."},
           "escape-bs-1":         {"type": "string", "value": "a \\\nb"},
           "escape-bs-2":         {"type": "string", "value": "a \\b"},
           "escape-bs-3":         {"type": "string", "value": "a \\\\\n  b"},
           "keep-ws-before":      {"type": "string", "value": "a   \tb"},
           "no-space":            {"type": "string", "value": "ab"},
           "whitespace-after-bs": {"type": "string", "value": "The quick brown fox jumps over the lazy dog."}
       }

FAIL valid/string/multiline-empty
     expected '='
     expected value
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       empty-1 = """"""

       # A newline immediately following the opening delimiter will be trimmed.
       empty-2 = """
       """

       # \ at the end of line trims newlines as well; note that last \ is followed by
       # two spaces, which are ignored.
       empty-3 = """\
           """
       empty-4 = """\
          \
          \
          """

     output from parser-cmd (stderr):
       expected '='
       expected value
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/string/multiline-escaped-crlf
     Key "0" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       # The following line should be an unescaped backslash followed by a Windows
       # newline sequence ("\r\n")
       0="""\
       """

     output from parser-cmd (stdout):
       {
         "0": "\\\r\n"
       }

     want:
       {
           "0": {"type": "string", "value": ""}
       }

FAIL valid/string/multiline-quotes
     invalid key
     invalid key
     expected '='
     expected value
     expected '='
     expected '='
     expected value
     expected '='
     unknown line
     expected '='
     expected value
     unknown line
     expected '='
     expected value
     unknown line
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       # Make sure that quotes inside multiline strings are allowed, including right
       # after the opening '''/""" and before the closing '''/"""

       lit_one = ''''one quote''''
       lit_two = '''''two quotes'''''
       lit_one_space = ''' 'one quote' '''
       lit_two_space = ''' ''two quotes'' '''

       one = """"one quote""""
       two = """""two quotes"""""
       one_space = """ "one quote" """
       two_space = """ ""two quotes"" """

       mismatch1 = """aaa'''bbb"""
       mismatch2 = '''aaa"""bbb'''

       # Three opening """, then one escaped ", then two "" (allowed), and then three
       # closing """
       escaped = """lol\""""""

       five-quotes = """
       Closing with five quotes
       """""
       four-quotes = """
       Closing with four quotes
       """"

     output from parser-cmd (stderr):
       invalid key
       invalid key
       expected '='
       expected value
       expected '='
       expected '='
       expected value
       expected '='
       unknown line
       expected '='
       expected value
       unknown line
       expected '='
       expected value
       unknown line
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/string/nl
     Key "lit_nl_end" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       nl_mid = "val\nue"
       nl_end = """value\n"""

       lit_nl_end = '''value\n'''
       lit_nl_mid = 'val\nue'
       lit_nl_uni = 'val\ue'

     output from parser-cmd (stdout):
       {
         "lit_nl_end": "value\\n",
         "lit_nl_mid": "val\\nue",
         "lit_nl_uni": "val\\ue",
         "nl_end":     "value\\n",
         "nl_mid":     "val\\nue"
       }

     want:
       {
           "lit_nl_end": {"type": "string", "value": "value\\n"},
           "lit_nl_mid": {"type": "string", "value": "val\\nue"},
           "lit_nl_uni": {"type": "string", "value": "val\\ue"},
           "nl_end":     {"type": "string", "value": "value\n"},
           "nl_mid":     {"type": "string", "value": "val\nue"}
       }

FAIL valid/string/quoted-unicode
     Key "basic_string" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:

       escaped_string = "\u0000 \u0008 \u000c \U00000041 \u007f \u0080 \u00ff \ud7ff \ue000 \uffff \U00010000 \U0010ffff"
       not_escaped_string = '\u0000 \u0008 \u000c \U00000041 \u007f \u0080 \u00ff \ud7ff \ue000 \uffff \U00010000 \U0010ffff'

       basic_string = "~       "
       literal_string = '~       '

     output from parser-cmd (stdout):
       {
         "basic_string":       "~       ",
         "escaped_string":     "\\u0000 \\u0008 \\u000c \\U00000041 \\u007f \\u0080 \\u00ff \\ud7ff \\ue000 \\uffff \\U00010000 \\U0010ffff",
         "literal_string":     "~       ",
         "not_escaped_string": "\\u0000 \\u0008 \\u000c \\U00000041 \\u007f \\u0080 \\u00ff \\ud7ff \\ue000 \\uffff \\U00010000 \\U0010ffff"
       }

     want:
       {
           "basic_string":   {"type": "string", "value": "~       "},
           "escaped_string": {"type": "string", "value": "\u0000 \b \f A        "},
           "literal_string": {"type": "string", "value": "~       "},
           "not_escaped_string": {
               "type":  "string",
               "value": "\\u0000 \\u0008 \\u000c \\U00000041 \\u007f \\u0080 \\u00ff \\ud7ff \\ue000 \\uffff \\U00010000 \\U0010ffff"
           }
       }

FAIL valid/string/raw
     Key "backslash" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       backspace = 'This string has a \b backspace character.'
       tab = 'This string has a \t tab character.'
       unescaped_tab = 'This string has an 	 unescaped tab character.'
       newline = 'This string has a \n new line character.'
       formfeed = 'This string has a \f form feed character.'
       carriage = 'This string has a \r carriage return character.'
       slash = 'This string has a \/ slash character.'
       backslash = 'This string has a \\ backslash character.'

     output from parser-cmd (stdout):
       {
         "backslash":     "This string has a \\\\ backslash character.",
         "backspace":     "This string has a \\b backspace character.",
         "carriage":      "This string has a \\r carriage return character.",
         "formfeed":      "This string has a \\f form feed character.",
         "newline":       "This string has a \\n new line character.",
         "slash":         "This string has a \\/ slash character.",
         "tab":           "This string has a \\t tab character.",
         "unescaped_tab": "This string has an \t unescaped tab character."
       }

     want:
       {
           "backslash":     {"type": "string", "value": "This string has a \\\\ backslash character."},
           "backspace":     {"type": "string", "value": "This string has a \\b backspace character."},
           "carriage":      {"type": "string", "value": "This string has a \\r carriage return character."},
           "formfeed":      {"type": "string", "value": "This string has a \\f form feed character."},
           "newline":       {"type": "string", "value": "This string has a \\n new line character."},
           "slash":         {"type": "string", "value": "This string has a \\/ slash character."},
           "tab":           {"type": "string", "value": "This string has a \\t tab character."},
           "unescaped_tab": {"type": "string", "value": "This string has an \t unescaped tab character."}
       }

FAIL valid/string/raw-multiline
     invalid key
     invalid literal string
     unknown line
     expected '='
     expected value
     unknown line
     Error: invalid toml
 
     Exit 1

     input sent to parser-cmd:
       # Single ' should be allowed.
       oneline = '''This string has a ' quote character.'''

       # A newline immediately following the opening delimiter will be trimmed.
       firstnl = '''
       This string has a ' quote character.'''

       # All other whitespace and newline characters remain intact.
       multiline = '''
       This string
       has ' a quote character
       and more than
       one newline
       in it.'''

       # Tab character in literal string does not need to be escaped
       multiline_with_tab = '''First line
       	 Followed by a tab'''

       this-str-has-apostrophes='''' there's one already
       '' two more
       '''''

     output from parser-cmd (stderr):
       invalid key
       invalid literal string
       unknown line
       expected '='
       expected value
       unknown line
       Error: invalid toml

       Exit 1

     want:
          <empty>

FAIL valid/string/simple
     Key "answer" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       answer = "You are not drinking enough whisky."

     output from parser-cmd (stdout):
       {
         "answer": "You are not drinking enough whisky."
       }

     want:
       {
           "answer": {"type": "string", "value": "You are not drinking enough whisky."}
       }

FAIL valid/string/start-mb
     Key "s1" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       # Start first line with a multibyte character.
       #
       # https://github.com/marzer/tomlplusplus/issues/190
       s1 = ""
       s2 = ''
       s3 = """\
       """
       s4 = """
       """
       s5 = """"""
       s6 = '''
       '''
       s7 = ''''''

     output from parser-cmd (stdout):
       {
         "s1": "",
         "s2": "",
         "s3": "\\\n",
         "s4": "\n",
         "s5": "",
         "s6": "\n",
         "s7": ""
       }

     want:
       {
           "s1": {"type": "string", "value": ""},
           "s2": {"type": "string", "value": ""},
           "s3": {"type": "string", "value": ""},
           "s4": {"type": "string", "value": ""},
           "s5": {"type": "string", "value": ""},
           "s6": {"type": "string", "value": ""},
           "s7": {"type": "string", "value": ""}
       }

FAIL valid/string/unicode-escape
     Key "a" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       delta-1 = "\u03B4"
       delta-2 = "\U000003B4"
       a       = "\u0061"
       b       = "\u0062"
       c       = "\U00000063"
       null-1  = "\u0000"
       null-2  = "\U00000000"

       ml-delta-1 = """\u03B4"""
       ml-delta-2 = """\U000003B4"""
       ml-a       = """\u0061"""
       ml-b       = """\u0062"""
       ml-c       = """\U00000063"""
       ml-null-1  = """\u0000"""
       ml-null-2  = """\U00000000"""

     output from parser-cmd (stdout):
       {
         "a":          "\\u0061",
         "b":          "\\u0062",
         "c":          "\\U00000063",
         "delta-1":    "\\u03B4",
         "delta-2":    "\\U000003B4",
         "ml-a":       "\\u0061",
         "ml-b":       "\\u0062",
         "ml-c":       "\\U00000063",
         "ml-delta-1": "\\u03B4",
         "ml-delta-2": "\\U000003B4",
         "ml-null-1":  "\\u0000",
         "ml-null-2":  "\\U00000000",
         "null-1":     "\\u0000",
         "null-2":     "\\U00000000"
       }

     want:
       {
           "a":          {"type": "string", "value": "a"},
           "b":          {"type": "string", "value": "b"},
           "c":          {"type": "string", "value": "c"},
           "delta-1":    {"type": "string", "value": ""},
           "delta-2":    {"type": "string", "value": ""},
           "ml-a":       {"type": "string", "value": "a"},
           "ml-b":       {"type": "string", "value": "b"},
           "ml-c":       {"type": "string", "value": "c"},
           "ml-delta-1": {"type": "string", "value": ""},
           "ml-delta-2": {"type": "string", "value": ""},
           "ml-null-1":  {"type": "string", "value": "\u0000"},
           "ml-null-2":  {"type": "string", "value": "\u0000"},
           "null-1":     {"type": "string", "value": "\u0000"},
           "null-2":     {"type": "string", "value": "\u0000"}
       }

FAIL valid/string/unicode-literal
     Key "answer" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       answer = ""

     output from parser-cmd (stdout):
       {
         "answer": ""
       }

     want:
       {
           "answer": {"type": "string", "value": ""}
       }

FAIL valid/string/with-pound
     Key "pound" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       pound = "We see no # comments here."
       poundcomment = "But there are # some comments here." # Did I # mess you up?

     output from parser-cmd (stdout):
       {
         "pound":        "We see no # comments here.",
         "poundcomment": "But there are # some comments here."
       }

     want:
       {
           "pound":        {"type": "string", "value": "We see no # comments here."},
           "poundcomment": {"type": "string", "value": "But there are # some comments here."}
       }

FAIL valid/table/array-implicit
     Key "albums.songs.name" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       [[albums.songs]]
       name = "Glory Days"

     output from parser-cmd (stdout):
       {
         "albums": {"songs": [{"name": "Glory Days"}]}
       }

     want:
       {
           "albums": {"songs": [{
               "name": {"type": "string", "value": "Glory Days"}
           }]}
       }

FAIL valid/table/array-implicit-and-explicit-after
     command timed out after 1s; increase -timeout if this isn't an infinite loop or pathological behaviour

     input sent to parser-cmd:
       [[a.b]]
       x = 1

       [a]
       y = 2

     output from parser-cmd (stdout):


     want:
          <empty>

FAIL valid/table/array-many
     Key "people.first_name" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       [[people]]
       first_name = "Bruce"
       last_name = "Springsteen"

       [[people]]
       first_name = "Eric"
       last_name = "Clapton"

       [[people]]
       first_name = "Bob"
       last_name = "Seger"

     output from parser-cmd (stdout):
       {
         "people": [
           {"first_name": "Bruce", "last_name": "Springsteen"},
           {"first_name": "Eric", "last_name": "Clapton"},
           {"first_name": "Bob", "last_name": "Seger"}
         ]
       }

     want:
       {
           "people": [
               {
                   "first_name": {"type": "string", "value": "Bruce"},
                   "last_name":  {"type": "string", "value": "Springsteen"}
               },
               {
                   "first_name": {"type": "string", "value": "Eric"},
                   "last_name":  {"type": "string", "value": "Clapton"}
               },
               {
                   "first_name": {"type": "string", "value": "Bob"},
                   "last_name":  {"type": "string", "value": "Seger"}
               }
           ]
       }

FAIL valid/table/array-nest
     Key "albums.name" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       [[albums]]
       name = "Born to Run"

         [[albums.songs]]
         name = "Jungleland"

         [[albums.songs]]
         name = "Meeting Across the River"

       [[albums]]
       name = "Born in the USA"

         [[albums.songs]]
         name = "Glory Days"

         [[albums.songs]]
         name = "Dancing in the Dark"

     output from parser-cmd (stdout):
       {
         "albums": [
           {
             "name": "Born to Run",
             "songs": [
               {"name": "Jungleland"},
               {"name": "Meeting Across the River"}
             ]
           },
           {
             "name": "Born in the USA",
             "songs": [
               {"name": "Glory Days"},
               {"name": "Dancing in the Dark"}
             ]
           }
         ]
       }

     want:
       {
           "albums": [
               {
                   "name": {"type": "string", "value": "Born to Run"},
                   "songs": [
                       {
                           "name": {"type": "string", "value": "Jungleland"}
                       },
                       {
                           "name": {"type": "string", "value": "Meeting Across the River"}
                       }
                   ]
               },
               {
                   "name": {"type": "string", "value": "Born in the USA"},
                   "songs": [
                       {
                           "name": {"type": "string", "value": "Glory Days"}
                       },
                       {
                           "name": {"type": "string", "value": "Dancing in the Dark"}
                       }
                   ]
               }
           ]
       }

FAIL valid/table/array-one
     Key "people.first_name" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       [[people]]
       first_name = "Bruce"
       last_name = "Springsteen"

     output from parser-cmd (stdout):
       {
         "people": [{"first_name": "Bruce", "last_name": "Springsteen"}]
       }

     want:
       {
           "people": [{
               "first_name": {"type": "string", "value": "Bruce"},
               "last_name":  {"type": "string", "value": "Springsteen"}
           }]
       }

FAIL valid/table/array-table-array
     Key "a.b.c.d" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       [[a]]
           [[a.b]]
               [a.b.c]
                   d = "val0"
           [[a.b]]
               [a.b.c]
                   d = "val1"

     output from parser-cmd (stdout):
       {
         "a": [{"b": [
           {
             "c": {"d": "val0"}
           },
           {
             "c": {"d": "val1"}
           }
         ]}]
       }

     want:
       {
           "a": [{
               "b": [
                   {
                       "c": {
                           "d": {"type": "string", "value": "val0"}
                       }
                   },
                   {
                       "c": {
                           "d": {"type": "string", "value": "val1"}
                       }
                   }
               ]
           }]
       }

FAIL valid/table/array-within-dotted
     Key "fruit.apple.color" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       [fruit]
       apple.color = "red"

       [[fruit.apple.seeds]]
       size = 2

     output from parser-cmd (stdout):
       {
         "fruit": {
           "apple": {"color": "red", "seeds": [{"size": 2}]}
         }
       }

     want:
       {
           "fruit": {
               "apple": {
                   "color": {"type": "string", "value": "red"},
                   "seeds": [{
                       "size": {"type": "integer", "value": "2"}
                   }]
               }
           }
       }

FAIL valid/table/empty-name
     Key "a.x" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       ['']
       x = 1

       ["".a]
       x = 2

       [a.'']
       x = 3

     output from parser-cmd (stdout):
       {
         "": {
           "a": {"x": 2},
           "x": 1
         },
         "a": {
           "": {"x": 3}
         }
       }

     want:
       {
           "": {
               "x": {"type": "integer", "value": "1"},
               "a": {
                   "x": {"type": "integer", "value": "2"}
               }
           },
           "a": {
               "": {
                   "x": {"type": "integer", "value": "3"}
               }
           }
       }

FAIL valid/table/keyword
     Could not find key "inf" in parser output.

     input sent to parser-cmd:
       [true]

       [false]

       [inf]

       [nan]

     output from parser-cmd (stdout):
       {
         "false": {},
         "true":  {}
       }

     want:
       {
           "false": {},
           "inf":   {},
           "nan":   {},
           "true":  {}
       }

FAIL valid/table/names
     Could not find key "x.1" in parser output.

     input sent to parser-cmd:
       [a.b.c]
       [a."b.c"]
       [a.'d.e']
       [a.' x ']
       [ d.e.f ]
       [ g . h . i ]
       [ j . "" . 'l' ]

       [x.1.2]

     output from parser-cmd (stdout):
       {
         "x": {},
         "a": {
           " x ": {},
           "b.c": {},
           "d.e": {},
           "b": {
             "c": {}
           }
         },
         "d": {
           "e": {
             "f": {}
           }
         },
         "g": {
           "h": {
             "i": {}
           }
         },
         "j": {
           "": {
             "l": {}
           }
         }
       }

     want:
       {
           "a": {
               " x ": {},
               "b.c": {},
               "d.e": {},
               "b": {
                   "c": {}
               }
           },
           "d": {
               "e": {
                   "f": {}
               }
           },
           "g": {
               "h": {
                   "i": {}
               }
           },
           "j": {
               "": {
                   "l": {}
               }
           },
           "x": {
               "1": {
                   "2": {}
               }
           }
       }

FAIL valid/table/sub
     Key "a.extend.key" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       [a]
       key = 1

       # a.extend is a key inside the "a" table.
       [a.extend]
       key = 2

       [a.extend.more]
       key = 3

     output from parser-cmd (stdout):
       {
         "a": {
           "key": 1,
           "extend": {
             "key":  2,
             "more": {"key": 3}
           }
         }
       }

     want:
       {
           "a": {
               "key": {"type": "integer", "value": "1"},
               "extend": {
                   "key": {"type": "integer", "value": "2"},
                   "more": {
                       "key": {"type": "integer", "value": "3"}
                   }
               }
           }
       }

FAIL valid/table/with-literal-string
     Key "a.\"b\".c.answer" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       ['a']
       [a.'"b"']
       [a.'"b"'.c]
       answer = 42

     output from parser-cmd (stdout):
       {
         "a": {
           "\"b\"": {
             "c": {"answer": 42}
           }
         }
       }

     want:
       {
           "a": {
               "\"b\"": {
                   "c": {
                       "answer": {"type": "integer", "value": "42"}
                   }
               }
           }
       }

FAIL valid/table/with-pound
     Key "key#group.answer" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       ["key#group"]
       answer = 42

     output from parser-cmd (stdout):
       {
         "key#group": {"answer": 42}
       }

     want:
       {
           "key#group": {
               "answer": {"type": "integer", "value": "42"}
           }
       }

FAIL valid/table/with-single-quotes
     Key "a.b.c.answer" (type "table"):
       Expected:     map[string]any(nil)
       Your encoder: map[string]any

     input sent to parser-cmd:
       ['a']
       [a.'b']
       [a.'b'.c]
       answer = 42

     output from parser-cmd (stdout):
       {
         "a": {
           "b": {
             "c": {"answer": 42}
           }
         }
       }

     want:
       {
           "a": {
               "b": {
                   "c": {
                       "answer": {"type": "integer", "value": "42"}
                   }
               }
           }
       }

FAIL invalid/control/bare-cr
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       # The following line contains a single carriage return control character
       

     output from parser-cmd (stdout):
       {}

     want:
       Exit code 1

FAIL invalid/control/comment-cr
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       comment-cr   = "Carriage return in comment" # a=1

     output from parser-cmd (stdout):
       {
         "a":          1,
         "comment-cr": "Carriage return in comment"
       }

     want:
       Exit code 1

FAIL invalid/control/comment-del
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       comment-del  = "0x7f"   # 

     output from parser-cmd (stdout):
       {
         "comment-del": "0x7f"
       }

     want:
       Exit code 1

FAIL invalid/control/comment-ff
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       comment-ff   = "0x7f"   # 

     output from parser-cmd (stdout):
       {
         "comment-ff": "0x7f"
       }

     want:
       Exit code 1

FAIL invalid/control/comment-lf
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       comment-lf   = "ctrl-P" # 

     output from parser-cmd (stdout):
       {
         "comment-lf": "ctrl-P"
       }

     want:
       Exit code 1

FAIL invalid/control/comment-null
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       comment-null = "null"   #  

     output from parser-cmd (stdout):
       {
         "comment-null": "null"
       }

     want:
       Exit code 1

FAIL invalid/control/comment-us
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       comment-us   = "ctrl-_" # 

     output from parser-cmd (stdout):
       {
         "comment-us": "ctrl-_"
       }

     want:
       Exit code 1

FAIL invalid/control/multi-cr
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       multi-cr   = """null"""

     output from parser-cmd (stdout):
       {
         "multi-cr": "null\r"
       }

     want:
       Exit code 1

FAIL invalid/control/multi-del
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       multi-del  = """null"""

     output from parser-cmd (stdout):
       {
         "multi-del": "null"
       }

     want:
       Exit code 1

FAIL invalid/control/multi-lf
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       multi-lf   = """null"""

     output from parser-cmd (stdout):
       {
         "multi-lf": "null\u0010"
       }

     want:
       Exit code 1

FAIL invalid/control/multi-null
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       multi-null = """null """

     output from parser-cmd (stdout):
       {
         "multi-null": "null\u0000"
       }

     want:
       Exit code 1

FAIL invalid/control/multi-us
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       multi-us   = """null"""

     output from parser-cmd (stdout):
       {
         "multi-us": "null\u001f"
       }

     want:
       Exit code 1

FAIL invalid/control/rawmulti-cd
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       rawmulti-cd   = '''null'''

     output from parser-cmd (stdout):
       {
         "rawmulti-cd": "null\r"
       }

     want:
       Exit code 1

FAIL invalid/control/rawmulti-del
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       rawmulti-del  = '''null'''

     output from parser-cmd (stdout):
       {
         "rawmulti-del": "null"
       }

     want:
       Exit code 1

FAIL invalid/control/rawmulti-lf
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       rawmulti-lf   = '''null'''

     output from parser-cmd (stdout):
       {
         "rawmulti-lf": "null\u0010"
       }

     want:
       Exit code 1

FAIL invalid/control/rawmulti-null
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       rawmulti-null = '''null '''

     output from parser-cmd (stdout):
       {
         "rawmulti-null": "null\u0000"
       }

     want:
       Exit code 1

FAIL invalid/control/rawmulti-us
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       rawmulti-us   = '''null'''

     output from parser-cmd (stdout):
       {
         "rawmulti-us": "null\u001f"
       }

     want:
       Exit code 1

FAIL invalid/control/rawstring-del
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       rawstring-del  = 'null'

     output from parser-cmd (stdout):
       {
         "rawstring-del": "null"
       }

     want:
       Exit code 1

FAIL invalid/control/rawstring-lf
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       rawstring-lf   = 'null'

     output from parser-cmd (stdout):
       {
         "rawstring-lf": "null\u0010"
       }

     want:
       Exit code 1

FAIL invalid/control/rawstring-null
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       rawstring-null = 'null '

     output from parser-cmd (stdout):
       {
         "rawstring-null": "null\u0000"
       }

     want:
       Exit code 1

FAIL invalid/control/rawstring-us
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       rawstring-us   = 'null'

     output from parser-cmd (stdout):
       {
         "rawstring-us": "null\u001f"
       }

     want:
       Exit code 1

FAIL invalid/control/string-bs
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       string-bs   = "backspace"

     output from parser-cmd (stdout):
       {
         "string-bs": "backspace\b"
       }

     want:
       Exit code 1

FAIL invalid/control/string-del
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       string-del  = "null"

     output from parser-cmd (stdout):
       {
         "string-del": "null"
       }

     want:
       Exit code 1

FAIL invalid/control/string-lf
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       string-lf   = "null"

     output from parser-cmd (stdout):
       {
         "string-lf": "null\u0010"
       }

     want:
       Exit code 1

FAIL invalid/control/string-null
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       string-null = "null "

     output from parser-cmd (stdout):
       {
         "string-null": "null\u0000"
       }

     want:
       Exit code 1

FAIL invalid/control/string-us
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       string-us   = "null"

     output from parser-cmd (stdout):
       {
         "string-us": "null\u001f"
       }

     want:
       Exit code 1

FAIL invalid/datetime/no-leads
     command timed out after 1s; increase -timeout if this isn't an infinite loop or pathological behaviour

     input sent to parser-cmd:
       # Month "7" instead of "07"; the leading zero is required.
       no-leads = 1987-7-05T17:45:00Z

     output from parser-cmd (stdout):


     want:
       Exit code 1

FAIL invalid/datetime/no-secs
     command timed out after 1s; increase -timeout if this isn't an infinite loop or pathological behaviour

     input sent to parser-cmd:
       # No seconds in time.
       no-secs = 1987-07-05T17:45Z

     output from parser-cmd (stdout):


     want:
       Exit code 1

FAIL invalid/datetime/no-t
     command timed out after 1s; increase -timeout if this isn't an infinite loop or pathological behaviour

     input sent to parser-cmd:
       # No "t" or "T" between the date and time.
       no-t = 1987-07-0517:45:00Z

     output from parser-cmd (stdout):


     want:
       Exit code 1

FAIL invalid/datetime/offset-overflow-hour
     command timed out after 1s; increase -timeout if this isn't an infinite loop or pathological behaviour

     input sent to parser-cmd:
       # Hour must be 00-24
       d = 1985-06-18 17:04:07+25:00

     output from parser-cmd (stdout):


     want:
       Exit code 1

FAIL invalid/datetime/offset-overflow-minute
     command timed out after 1s; increase -timeout if this isn't an infinite loop or pathological behaviour

     input sent to parser-cmd:
       # Minute must be 00-59; we allow 60 too because some people do write offsets of
       # 60 minutes
       d = 1985-06-18 17:04:07+12:61

     output from parser-cmd (stdout):


     want:
       Exit code 1

FAIL invalid/datetime/second-over
     command timed out after 1s; increase -timeout if this isn't an infinite loop or pathological behaviour

     input sent to parser-cmd:
       # time-second     = 2DIGIT  ; 00-58, 00-59, 00-60 based on leap second
       #                           ; rules
       d = 2006-01-01T00:00:61-00:00

     output from parser-cmd (stdout):


     want:
       Exit code 1

FAIL invalid/datetime/time-no-leads
     command timed out after 1s; increase -timeout if this isn't an infinite loop or pathological behaviour

     input sent to parser-cmd:
       # Leading 0 is always required.
       d = 2023-10-01T1:32:00Z

     output from parser-cmd (stdout):


     want:
       Exit code 1

FAIL invalid/datetime/y10k
     command timed out after 1s; increase -timeout if this isn't an infinite loop or pathological behaviour

     input sent to parser-cmd:
       # Maximum RFC3399 year is 9999.
       d = 10000-01-01 00:00:00z

     output from parser-cmd (stdout):


     want:
       Exit code 1

FAIL invalid/encoding/bad-utf8-at-end
     command timed out after 1s; increase -timeout if this isn't an infinite loop or pathological behaviour

     input sent to parser-cmd:
       # There is a 0xda at after the quotes, and no EOL at the end of the file.
       #
       # This is a bit of an edge case: This indicates there should be two bytes
       # (0b1101_1010) but there is no byte to follow because it's the end of the file.
       x = """"""

     output from parser-cmd (stdout):


     want:
       Exit code 1

FAIL invalid/encoding/bad-utf8-in-comment
     command timed out after 1s; increase -timeout if this isn't an infinite loop or pathological behaviour

     input sent to parser-cmd:
       # 

     output from parser-cmd (stdout):


     want:
       Exit code 1

FAIL invalid/encoding/bad-utf8-in-multiline
     command timed out after 1s; increase -timeout if this isn't an infinite loop or pathological behaviour

     input sent to parser-cmd:
       # The following line contains an invalid UTF-8 sequence.
       bad = """"""

     output from parser-cmd (stdout):


     want:
       Exit code 1

FAIL invalid/encoding/bad-utf8-in-multiline-literal
     command timed out after 1s; increase -timeout if this isn't an infinite loop or pathological behaviour

     input sent to parser-cmd:
       # The following line contains an invalid UTF-8 sequence.
       bad = ''''''

     output from parser-cmd (stdout):


     want:
       Exit code 1

FAIL invalid/encoding/bad-utf8-in-string
     command timed out after 1s; increase -timeout if this isn't an infinite loop or pathological behaviour

     input sent to parser-cmd:
       # The following line contains an invalid UTF-8 sequence.
       bad = ""

     output from parser-cmd (stdout):


     want:
       Exit code 1

FAIL invalid/encoding/bad-utf8-in-string-literal
     signal: killed

     input sent to parser-cmd:
       # The following line contains an invalid UTF-8 sequence.
       bad = ''

     output from parser-cmd (stdout):


     want:
       Exit code 1

FAIL invalid/encoding/bom-not-at-start-1
     command timed out after 1s; increase -timeout if this isn't an infinite loop or pathological behaviour

     input sent to parser-cmd:
       bom-not-at-start 

     output from parser-cmd (stdout):


     want:
       Exit code 1

FAIL invalid/encoding/bom-not-at-start-2
     command timed out after 1s; increase -timeout if this isn't an infinite loop or pathological behaviour

     input sent to parser-cmd:
       bom-not-at-start= 

     output from parser-cmd (stdout):


     want:
       Exit code 1

FAIL invalid/encoding/utf16-bom
     command timed out after 1s; increase -timeout if this isn't an infinite loop or pathological behaviour

     input sent to parser-cmd:
        #   U T F - 1 6   w i t h   B O M 

     output from parser-cmd (stdout):


     want:
       Exit code 1

FAIL invalid/encoding/utf16-comment
     command timed out after 1s; increase -timeout if this isn't an infinite loop or pathological behaviour

     input sent to parser-cmd:
        #   U T F - 1 6   w i t h o u t   B O M 

     output from parser-cmd (stdout):


     want:
       Exit code 1

FAIL invalid/encoding/utf16-key
     command timed out after 1s; increase -timeout if this isn't an infinite loop or pathological behaviour

     input sent to parser-cmd:
        k   =   " v " 

     output from parser-cmd (stdout):


     want:
       Exit code 1

FAIL invalid/float/double-point-1
     command timed out after 1s; increase -timeout if this isn't an infinite loop or pathological behaviour

     input sent to parser-cmd:
       double-point-1 = 0..1

     output from parser-cmd (stdout):


     want:
       Exit code 1

FAIL invalid/float/double-point-2
     command timed out after 1s; increase -timeout if this isn't an infinite loop or pathological behaviour

     input sent to parser-cmd:
       double-point-2 = 0.1.2

     output from parser-cmd (stdout):


     want:
       Exit code 1

FAIL invalid/float/exp-double-e-1
     command timed out after 1s; increase -timeout if this isn't an infinite loop or pathological behaviour

     input sent to parser-cmd:
       exp-double-e-1 = 1ee2

     output from parser-cmd (stdout):


     want:
       Exit code 1

FAIL invalid/float/exp-double-e-2
     command timed out after 1s; increase -timeout if this isn't an infinite loop or pathological behaviour

     input sent to parser-cmd:
       exp-double-e-2 = 1e2e3

     output from parser-cmd (stdout):


     want:
       Exit code 1

FAIL invalid/float/leading-zero
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       leading-zero = 03.14

     output from parser-cmd (stdout):
       {
         "leading-zero": 3
       }

     want:
       Exit code 1

FAIL invalid/float/leading-zero-neg
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       leading-zero-neg = -03.14

     output from parser-cmd (stdout):
       {
         "leading-zero-neg": -3
       }

     want:
       Exit code 1

FAIL invalid/float/leading-zero-plus
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       leading-zero-plus = +03.14

     output from parser-cmd (stdout):
       {
         "leading-zero-plus": 3
       }

     want:
       Exit code 1

FAIL invalid/inline-table/duplicate-key-3
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       tbl = { fruit = { apple.color = "red" }, fruit.apple.texture = { smooth = true } }

     output from parser-cmd (stdout):
       {
         "tbl": {
           "fruit": {
             "apple": {
               "color":   "red",
               "texture": {"smooth": true}
             }
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/inline-table/overwrite-01
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       a.b=0
       # Since table "a" is already defined, it can't be replaced by an inline table.
       a={}

     output from parser-cmd (stdout):
       {
         "a": {"b": 0}
       }

     want:
       Exit code 1

FAIL invalid/inline-table/overwrite-02
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       a={}
       # Inline tables are immutable and can't be extended
       [a.b]

     output from parser-cmd (stdout):
       {
         "a": {
           "b": {}
         }
       }

     want:
       Exit code 1

FAIL invalid/inline-table/overwrite-05
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       inline-t = { nest = {} }

       [inline-t.nest]

     output from parser-cmd (stdout):
       {
         "inline-t": {
           "nest": {}
         }
       }

     want:
       Exit code 1

FAIL invalid/inline-table/overwrite-08
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       tab = { inner = { dog = "best" }, inner.cat = "worst" }

     output from parser-cmd (stdout):
       {
         "tab": {
           "inner": {"cat": "worst", "dog": "best"}
         }
       }

     want:
       Exit code 1

FAIL invalid/integer/leading-zero-1
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       leading-zero-1 = 01

     output from parser-cmd (stdout):
       {
         "leading-zero-1": 1
       }

     want:
       Exit code 1

FAIL invalid/integer/leading-zero-2
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       leading-zero-2 = 00

     output from parser-cmd (stdout):
       {
         "leading-zero-2": 0
       }

     want:
       Exit code 1

FAIL invalid/integer/leading-zero-sign-1
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       leading-zero-sign-1 = -01

     output from parser-cmd (stdout):
       {
         "leading-zero-sign-1": -1
       }

     want:
       Exit code 1

FAIL invalid/integer/leading-zero-sign-2
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       leading-zero-sign-2 = +01

     output from parser-cmd (stdout):
       {
         "leading-zero-sign-2": 1
       }

     want:
       Exit code 1

FAIL invalid/key/after-array
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [[agencies]] owner = "S Cjelli"

     output from parser-cmd (stdout):
       {
         "agencies": [{"owner": "S Cjelli"}]
       }

     want:
       Exit code 1

FAIL invalid/key/after-table
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [error] this = "should not be here"

     output from parser-cmd (stdout):
       {
         "error": {"this": "should not be here"}
       }

     want:
       Exit code 1

FAIL invalid/key/after-value
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       first = "Tom" last = "Preston-Werner" # INVALID

     output from parser-cmd (stdout):
       {
         "first": "Tom",
         "last":  "Preston-Werner"
       }

     want:
       Exit code 1

FAIL invalid/key/no-eol
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       a = 1 b = 2

     output from parser-cmd (stdout):
       {
         "a": 1,
         "b": 2
       }

     want:
       Exit code 1

FAIL invalid/spec/inline-table-2-0
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [product]
       type = { name = "Nail" }
       type.edible = false  # INVALID

     output from parser-cmd (stdout):
       {
         "product": {
           "type": {"edible": false, "name": "Nail"}
         }
       }

     want:
       Exit code 1

FAIL invalid/spec/inline-table-3-0
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [product]
       type.name = "Nail"
       type = { edible = false }  # INVALID

     output from parser-cmd (stdout):
       {
         "product": {
           "type": {"edible": false, "name": "Nail"}
         }
       }

     want:
       Exit code 1

FAIL invalid/spec/table-9-0
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [fruit]
       apple.color = "red"
       apple.taste.sweet = true

       [fruit.apple]  # INVALID
       # [fruit.apple.taste]  # INVALID

       [fruit.apple.texture]  # you can add sub-tables
       smooth = true

     output from parser-cmd (stdout):
       {
         "fruit": {
           "apple": {
             "color":   "red",
             "taste":   {"sweet": true},
             "texture": {"smooth": true}
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/spec/table-9-1
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [fruit]
       apple.color = "red"
       apple.taste.sweet = true

       # [fruit.apple]  # INVALID
       [fruit.apple.taste]  # INVALID

       [fruit.apple.texture]  # you can add sub-tables
       smooth = true

     output from parser-cmd (stdout):
       {
         "fruit": {
           "apple": {
             "color":   "red",
             "taste":   {"sweet": true},
             "texture": {"smooth": true}
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/string/bad-byte-escape
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       naughty = "\xAg"

     output from parser-cmd (stdout):
       {
         "naughty": "\\xAg"
       }

     want:
       Exit code 1

FAIL invalid/string/bad-escape-1
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       invalid-escape = "This string has a bad \a escape character."

     output from parser-cmd (stdout):
       {
         "invalid-escape": "This string has a bad \\a escape character."
       }

     want:
       Exit code 1

FAIL invalid/string/bad-escape-2
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       invalid-escape = "This string has a bad \  escape character."

     output from parser-cmd (stdout):
       {
         "invalid-escape": "This string has a bad \\  escape character."
       }

     want:
       Exit code 1

FAIL invalid/string/bad-hex-esc-1
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       bad-hex-esc-1 = "\x0g"

     output from parser-cmd (stdout):
       {
         "bad-hex-esc-1": "\\x0g"
       }

     want:
       Exit code 1

FAIL invalid/string/bad-hex-esc-2
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       bad-hex-esc-2 = "\xG0"

     output from parser-cmd (stdout):
       {
         "bad-hex-esc-2": "\\xG0"
       }

     want:
       Exit code 1

FAIL invalid/string/bad-hex-esc-3
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       bad-hex-esc-3 = "\x"

     output from parser-cmd (stdout):
       {
         "bad-hex-esc-3": "\\x"
       }

     want:
       Exit code 1

FAIL invalid/string/bad-hex-esc-4
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       bad-hex-esc-4 = "\x 50"

     output from parser-cmd (stdout):
       {
         "bad-hex-esc-4": "\\x 50"
       }

     want:
       Exit code 1

FAIL invalid/string/bad-hex-esc-5
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       bad-hex-esc-5 = "\x 50"

     output from parser-cmd (stdout):
       {
         "bad-hex-esc-5": "\\x 50"
       }

     want:
       Exit code 1

FAIL invalid/string/bad-slash-escape
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       invalid-escape = "This string has a bad \/ escape character."

     output from parser-cmd (stdout):
       {
         "invalid-escape": "This string has a bad \\/ escape character."
       }

     want:
       Exit code 1

FAIL invalid/string/bad-uni-esc-1
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       bad-uni-esc-1 = "val\ue"

     output from parser-cmd (stdout):
       {
         "bad-uni-esc-1": "val\\ue"
       }

     want:
       Exit code 1

FAIL invalid/string/bad-uni-esc-2
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       bad-uni-esc-2 = "val\Ux"

     output from parser-cmd (stdout):
       {
         "bad-uni-esc-2": "val\\Ux"
       }

     want:
       Exit code 1

FAIL invalid/string/bad-uni-esc-3
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       bad-uni-esc-3 = "val\U0000000"

     output from parser-cmd (stdout):
       {
         "bad-uni-esc-3": "val\\U0000000"
       }

     want:
       Exit code 1

FAIL invalid/string/bad-uni-esc-4
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       bad-uni-esc-4 = "val\U0000"

     output from parser-cmd (stdout):
       {
         "bad-uni-esc-4": "val\\U0000"
       }

     want:
       Exit code 1

FAIL invalid/string/bad-uni-esc-5
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       bad-uni-esc-5 = "val\Ugggggggg"

     output from parser-cmd (stdout):
       {
         "bad-uni-esc-5": "val\\Ugggggggg"
       }

     want:
       Exit code 1

FAIL invalid/string/bad-uni-esc-6
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       bad-uni-esc-6 = "This string contains a non scalar unicode codepoint \uD801"

     output from parser-cmd (stdout):
       {
         "bad-uni-esc-6": "This string contains a non scalar unicode codepoint \\uD801"
       }

     want:
       Exit code 1

FAIL invalid/string/bad-uni-esc-7
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       bad-uni-esc-7 = "\uabag"

     output from parser-cmd (stdout):
       {
         "bad-uni-esc-7": "\\uabag"
       }

     want:
       Exit code 1

FAIL invalid/string/basic-byte-escapes
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       answer = "\x33"

     output from parser-cmd (stdout):
       {
         "answer": "\\x33"
       }

     want:
       Exit code 1

FAIL invalid/string/basic-multiline-out-of-range-unicode-escape-1
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       a = """\UFFFFFFFF"""

     output from parser-cmd (stdout):
       {
         "a": "\\UFFFFFFFF"
       }

     want:
       Exit code 1

FAIL invalid/string/basic-multiline-out-of-range-unicode-escape-2
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       a = """\U00D80000"""

     output from parser-cmd (stdout):
       {
         "a": "\\U00D80000"
       }

     want:
       Exit code 1

FAIL invalid/string/basic-multiline-unknown-escape
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       a = """\@"""

     output from parser-cmd (stdout):
       {
         "a": "\\@"
       }

     want:
       Exit code 1

FAIL invalid/string/basic-out-of-range-unicode-escape-1
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       a = "\UFFFFFFFF"

     output from parser-cmd (stdout):
       {
         "a": "\\UFFFFFFFF"
       }

     want:
       Exit code 1

FAIL invalid/string/basic-out-of-range-unicode-escape-2
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       a = "\U00D80000"

     output from parser-cmd (stdout):
       {
         "a": "\\U00D80000"
       }

     want:
       Exit code 1

FAIL invalid/string/basic-unknown-escape
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       a = "\@"

     output from parser-cmd (stdout):
       {
         "a": "\\@"
       }

     want:
       Exit code 1

FAIL invalid/string/multiline-bad-escape-1
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       k = """t\a"""

     output from parser-cmd (stdout):
       {
         "k": "t\\a"
       }

     want:
       Exit code 1

FAIL invalid/string/multiline-bad-escape-2
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       # \<Space> is not a valid escape.
       k = """t\ t"""

     output from parser-cmd (stdout):
       {
         "k": "t\\ t"
       }

     want:
       Exit code 1

FAIL invalid/string/multiline-bad-escape-3
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       # \<Space> is not a valid escape.
       k = """t\ """

     output from parser-cmd (stdout):
       {
         "k": "t\\ "
       }

     want:
       Exit code 1

FAIL invalid/string/multiline-bad-escape-4
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       backslash = """\"""

     output from parser-cmd (stdout):
       {
         "backslash": "\\"
       }

     want:
       Exit code 1

FAIL invalid/string/multiline-escape-space-1
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       a = """
         foo \ \n
         bar"""

     output from parser-cmd (stdout):
       {
         "a": "\n  foo \\ \\n\n  bar"
       }

     want:
       Exit code 1

FAIL invalid/string/multiline-escape-space-2
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       bee = """
       hee \

       gee \   """

     output from parser-cmd (stdout):
       {
         "bee": "\nhee \\\n\ngee \\   "
       }

     want:
       Exit code 1

FAIL invalid/table/append-with-dotted-keys-1
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       # First a.b.c defines a table: a.b.c = {z=9}
       #
       # Then we define a.b.c.t = "str" to add a str to the above table, making it:
       #
       #   a.b.c = {z=9, t="..."}
       #
       # While this makes sense, logically, it was decided this is not valid TOML as
       # it's too confusing/convoluted.
       #
       # See: https://github.com/toml-lang/toml/issues/846
       #      https://github.com/toml-lang/toml/pull/859

       [a.b.c]
         z = 9

       [a]
         b.c.t = "Using dotted keys to add to [a.b.c] after explicitly defining it above is not allowed"

     output from parser-cmd (stdout):
       {
         "a": {
           "b": {
             "c": {
               "t": "Using dotted keys to add to [a.b.c] after explicitly defining it above is not allowed",
               "z": 9
             }
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/table/append-with-dotted-keys-2
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       # This is the same issue as in injection-1.toml, except that nests one level
       # deeper. See that file for a more complete description.

       [a.b.c.d]
         z = 9

       [a]
         b.c.d.k.t = "Using dotted keys to add to [a.b.c.d] after explicitly defining it above is not allowed"

     output from parser-cmd (stdout):
       {
         "a": {
           "b": {
             "c": {
               "d": {
                 "z": 9,
                 "k": {
                   "t": "Using dotted keys to add to [a.b.c.d] after explicitly defining it above is not allowed"
                 }
               }
             }
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/table/duplicate
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [a]
       b = 1

       [a]
       c = 2

     output from parser-cmd (stdout):
       {
         "a": {"b": 1, "c": 2}
       }

     want:
       Exit code 1

FAIL invalid/table/duplicate-key-dotted-table
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [fruit]
       apple.color = "red"

       [fruit.apple] # INVALID

     output from parser-cmd (stdout):
       {
         "fruit": {
           "apple": {"color": "red"}
         }
       }

     want:
       Exit code 1

FAIL invalid/table/duplicate-key-dotted-table2
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [fruit]
       apple.taste.sweet = true

       [fruit.apple.taste] # INVALID

     output from parser-cmd (stdout):
       {
         "fruit": {
           "apple": {
             "taste": {"sweet": true}
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/table/redefine-2
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [t1]
       t2.t3.v = 0
       [t1.t2]

     output from parser-cmd (stdout):
       {
         "t1": {
           "t2": {
             "t3": {"v": 0}
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/table/redefine-3
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [t1]
       t2.t3.v = 0
       [t1.t2.t3]

     output from parser-cmd (stdout):
       {
         "t1": {
           "t2": {
             "t3": {"v": 0}
           }
         }
       }

     want:
       Exit code 1

FAIL invalid/table/super-twice
     Expected an error, but no error was reported.

     input sent to parser-cmd:
       [a.b]
       [a]
       [a]

     output from parser-cmd (stdout):
       {
         "a": {
           "b": {}
         }
       }

     want:
       Exit code 1

toml-test v0001-01-01 [cargo decode]: using embedded tests
  valid tests:  15 passed, 167 failed
invalid tests: 265 passed, 106 failed
